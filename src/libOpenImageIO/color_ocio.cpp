// Copyright Contributors to the OpenImageIO project.
// SPDX-License-Identifier: Apache-2.0
// https://github.com/AcademySoftwareFoundation/OpenImageIO

#include <algorithm>
#include <array>
#include <cmath>
#include <limits>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include <tsl/robin_map.h>
#include <tsl/robin_set.h>

#include <OpenImageIO/Imath.h>

#include <OpenImageIO/color.h>
#include <OpenImageIO/filesystem.h>
#include <OpenImageIO/imagebufalgo.h>
#include <OpenImageIO/imagebufalgo_util.h>
#include <OpenImageIO/strutil.h>
#include <OpenImageIO/sysutil.h>

#include "imageio_pvt.h"

#define MAKE_OCIO_VERSION_HEX(maj, min, patch) \
    (((maj) << 24) | ((min) << 16) | (patch))

#include <OpenColorIO/OpenColorIO.h>

namespace OCIO = OCIO_NAMESPACE;


OIIO_NAMESPACE_3_1_BEGIN

namespace ConfigUtils {
// A single colorspace fingerprint (computed values + reference space type).
struct Fingerprint {
    std::string csName;
    OCIO::ReferenceSpaceType type;
    std::vector<float> vals;
};

// Precomputed fingerprints + reference test values for a config.
struct ColorSpaceFingerprints {
    std::vector<Fingerprint> vec;
    std::vector<float> sceneRefTestVals;
    std::vector<float> displayRefTestVals;
};

// Cache entry keyed by config+context cache ID.
struct FingerprintCacheEntry {
    std::string cache_id;
    ColorSpaceFingerprints fingerprints;
    std::unordered_map<std::string, Fingerprint> by_name;
    double seconds             = 0.0;
    bool test_vals_initialized = false;
};

using FingerprintCacheMap
    = std::unordered_map<std::string, FingerprintCacheEntry>;
class FastColorSpaceMatcher;
OCIO::ConfigRcPtr
adaptConfigReferenceSpaces(const OCIO::ConstConfigRcPtr& config,
                           const OCIO::ConstConfigRcPtr& otherConfig);
}  // namespace ConfigUtils

namespace {


// This file is generated by cmake at build-time, and contains the
// contents of OIIO's built-in interop-identities-config.ocio file
// encoded as a C string literal constant named
// kBuiltinInteropIdentitiesConfig. The file should not be edited
// by hand, or exported to a public header.
#include "interop_identities_config.h"



// Some test colors we use to interrogate transformations
static const int n_test_colors = 5;
static const Imath::C3f test_colors[n_test_colors]
    = { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 }, { 1, 1, 1 }, { 0.5, 0.5, 0.5 } };
}  // namespace


#if 1 || !defined(NDEBUG) /* allow color configuration debugging */
static bool colordebug = Strutil::stoi(Sysutil::getenv("OIIO_DEBUG_COLOR"))
                         || Strutil::stoi(Sysutil::getenv("OIIO_DEBUG_ALL"));
#    define DBG(...)    \
        if (colordebug) \
        Strutil::print(__VA_ARGS__)
#else
#    define DBG(...)
#endif


static int disable_ocio = Strutil::stoi(Sysutil::getenv("OIIO_DISABLE_OCIO"));
static int disable_builtin_configs = Strutil::stoi(
    Sysutil::getenv("OIIO_DISABLE_BUILTIN_OCIO_CONFIGS"));
static int disable_equality_reverse_cache = Strutil::stoi(
    Sysutil::getenv("OIIO_DISABLE_EQUALITY_REVERSE_CACHE"));
static OCIO::ConstConfigRcPtr ocio_current_config;



const ColorConfig&
ColorConfig::default_colorconfig()
{
    static ColorConfig config;
    return config;
}



// Class used as the key to index color processors in the cache.
class ColorProcCacheKey {
public:
    ColorProcCacheKey(ustring in, ustring out, ustring key = ustring(),
                      ustring val = ustring(), ustring looks = ustring(),
                      ustring display = ustring(), ustring view = ustring(),
                      ustring file           = ustring(),
                      ustring namedtransform = ustring(), bool inverse = false)
        : inputColorSpace(in)
        , outputColorSpace(out)
        , context_key(key)
        , context_value(val)
        , looks(looks)
        , file(file)
        , namedtransform(namedtransform)
        , inverse(inverse)
    {
        hash = inputColorSpace.hash() + 14033ul * outputColorSpace.hash()
               + 823ul * context_key.hash() + 28411ul * context_value.hash()
               + 1741ul
                     * (looks.hash() + display.hash() + view.hash()
                        + file.hash() + namedtransform.hash())
               + (inverse ? 6421 : 0);
        // N.B. no separate multipliers for looks, display, view, file,
        // namedtransform, because they're never used for the same lookup.
    }

    friend bool operator<(const ColorProcCacheKey& a,
                          const ColorProcCacheKey& b)
    {
        return std::tie(a.hash, a.inputColorSpace, a.outputColorSpace,
                        a.context_key, a.context_value, a.looks, a.display,
                        a.view, a.file, a.namedtransform, a.inverse)
               < std::tie(b.hash, b.inputColorSpace, b.outputColorSpace,
                          b.context_key, b.context_value, b.looks, b.display,
                          b.view, b.file, b.namedtransform, b.inverse);
    }

    friend bool operator==(const ColorProcCacheKey& a,
                           const ColorProcCacheKey& b)
    {
        return std::tie(a.hash, a.inputColorSpace, a.outputColorSpace,
                        a.context_key, a.context_value, a.looks, a.display,
                        a.view, a.file, a.namedtransform, a.inverse)
               == std::tie(b.hash, b.inputColorSpace, b.outputColorSpace,
                           b.context_key, b.context_value, b.looks, b.display,
                           b.view, b.file, b.namedtransform, b.inverse);
    }
    ustring inputColorSpace;
    ustring outputColorSpace;
    ustring context_key;
    ustring context_value;
    ustring looks;
    ustring display;
    ustring view;
    ustring file;
    ustring namedtransform;
    bool inverse;
    size_t hash;
};


struct ColorProcCacheKeyHasher {
    size_t operator()(const ColorProcCacheKey& c) const { return c.hash; }
};


typedef tsl::robin_map<ColorProcCacheKey, ColorProcessorHandle,
                       ColorProcCacheKeyHasher>
    ColorProcessorMap;



bool
ColorConfig::supportsOpenColorIO()
{
    return (disable_ocio == 0);
}



int
ColorConfig::OpenColorIO_version_hex()
{
    return OCIO_VERSION_HEX;
}


struct CSInfo {
    std::string name;  // Name of this color space
    int index;         // More than one can have the same index -- aliases
    enum Flags {
        none               = 0,
        is_linear_response = 1,   // any cs with linear transfer function
        is_scene_linear    = 2,   // equivalent to scene_linear
        is_srgb            = 4,   // sRGB (primaries, and transfer function)
        is_lin_srgb        = 8,   // sRGB/Rec709 primaries, linear response
        is_ACEScg          = 16,  // ACEScg
        is_Rec709          = 32,  // Rec709 primaries and transfer function
        is_known           = is_srgb | is_lin_srgb | is_ACEScg | is_Rec709
    };
    int m_flags   = 0;
    bool examined = false;
    std::string canonical;  // Canonical name for this color space
    OCIO::ConstColorSpaceRcPtr ocio_cs;

    CSInfo(string_view name_, int index_, int flags_ = none,
           string_view canonical_ = "")
        : name(name_)
        , index(index_)
        , m_flags(flags_)
        , canonical(canonical_)
    {
    }

    void setflag(int flagval) { m_flags |= flagval; }

    // Set flag to include any bits in flagval, and also if alias is not yet
    // set, set it to name.
    void setflag(int flagval, std::string& alias)
    {
        m_flags |= flagval;
        if (alias.empty())
            alias = name;
    }

    int flags() const { return m_flags; }
};



// Hidden implementation of ColorConfig
class ColorConfig::Impl {
public:
    OCIO::ConstConfigRcPtr config_;
    OCIO::ConstConfigRcPtr builtinconfig_;
    OCIO::ConstConfigRcPtr interopconfig_;

private:
    std::vector<CSInfo> colorspaces;
    std::string scene_linear_alias;  // Alias for a scene-linear color space
    std::string lin_srgb_alias;
    std::string srgb_alias;
    std::string ACEScg_alias;
    std::string Rec709_alias;
    // Two directional maps to avoid O(n) scans on reverse lookups.
    // equality_id -> colorspace is used by resolve(); colorspace -> equality_id
    // is used for fast interop/equality queries.
    mutable tsl::robin_map<std::string, tsl::robin_map<std::string, std::string>>
        m_equality_id_to_cs_by_ctx;
    mutable tsl::robin_map<std::string, tsl::robin_map<std::string, std::string>>
        m_cs_to_equality_id_by_ctx;
    mutable tsl::robin_set<std::string> m_equality_map_initialized_ctx;
    mutable spin_rw_mutex m_mutex;
    mutable std::string m_error;
    ColorProcessorMap colorprocmap;  // cache of ColorProcessors
    atomic_int colorprocs_requested;
    atomic_int colorprocs_created;
    std::string m_configname;
    std::string m_configfilename;
    ColorConfig* m_self       = nullptr;
    bool m_config_is_built_in = false;
    mutable std::vector<std::string> m_simple_color_spaces_cache;
    mutable bool m_simple_color_spaces_cached = false;
    mutable std::mutex m_fingerprint_cache_mutex;
    mutable ConfigUtils::FingerprintCacheMap m_fingerprint_cache;
    mutable std::unique_ptr<ConfigUtils::FastColorSpaceMatcher> m_interop_matcher;
    mutable std::mutex m_interop_matcher_mutex;
    mutable std::atomic<bool> m_equality_reverse_cache_enabled { true };

public:
    Impl(ColorConfig* self)
        : m_self(self)
    {
    }

    ~Impl()
    {
#if 0
        // Debugging the cache -- make sure we're creating a small number
        // compared to repeated requests.
        if (colorprocs_requested)
            DBG("ColorConfig::Impl : color procs requested: {}, created: {}\n",
                           colorprocs_requested, colorprocs_created);
#endif
    }

    bool init(string_view filename);

    std::map<std::string, std::string> get_equality_ids() const;
    std::map<std::string, std::string>
    get_equality_ids(bool exhaustive,
                     const std::map<std::string, std::string>& context) const;

    std::map<std::string, std::string>
    get_interop_ids(bool strict, bool exhaustive,
                    const std::map<std::string, std::string>& context) const;
    std::vector<float> get_colorspace_fingerprint(
        string_view colorspace,
        const std::map<std::string, std::string>& context) const;
    std::string find_colorspace_from_fingerprint(
        const std::vector<float>& fingerprint, bool display_referred,
        const std::map<std::string, std::string>& context) const;
    std::vector<std::pair<std::string, std::string>> get_intersection(
        const ColorConfig& other,
        const std::map<std::string, std::string>& base_context,
        const std::map<std::string, std::string>& other_context) const;
    std::string get_color_interop_id(
        string_view colorspace, bool strict,
        const std::map<std::string, std::string>& context) const;
    ConfigUtils::FastColorSpaceMatcher& get_interop_matcher() const;
    std::string context_cache_id(const OCIO::ConstContextRcPtr& context) const
    {
        const char* id = context ? context->getCacheID() : nullptr;
        return (id && *id) ? std::string(id) : std::string();
    }
    std::string equality_cache_key(const OCIO::ConstConfigRcPtr& config,
                                   const OCIO::ConstContextRcPtr& context) const
    {
        const std::string ctx_id    = context_cache_id(context);
        const std::string config_id = config ? config->getCacheID()
                                             : std::string();
        return Strutil::fmt::format("{}@{}", ctx_id, config_id);
    }

    void add(const std::string& name, int index, int flags = 0)
    {
        spin_rw_write_lock lock(m_mutex);
        colorspaces.emplace_back(name, index, flags);
        // classify(colorspaces.back());
    }
    void clear_colorproc_cache()
    {
        spin_rw_write_lock lock(m_mutex);
        colorprocmap.clear();
    }

    // Find the CSInfo record for the named color space, or nullptr if it's
    // not a color space we know.
    const CSInfo* find(string_view name) const
    {
        for (auto&& cs : colorspaces)
            if (cs.name == name)
                return &cs;
        return nullptr;
    }
    CSInfo* find(string_view name)
    {
        for (auto&& cs : colorspaces)
            if (cs.name == name)
                return &cs;
        return nullptr;
    }

    // Search for a matching ColorProcessor, return it if found (otherwise
    // return an empty handle).
    ColorProcessorHandle findproc(const ColorProcCacheKey& key)
    {
        ++colorprocs_requested;
        spin_rw_read_lock lock(m_mutex);
        auto found = colorprocmap.find(key);
        return (found == colorprocmap.end()) ? ColorProcessorHandle()
                                             : found->second;
    }

    // Add the given color processor. Be careful -- if a matching one is
    // already in the table, just return the existing one. If they pass
    // in an empty handle, just return it.
    ColorProcessorHandle addproc(const ColorProcCacheKey& key,
                                 ColorProcessorHandle handle)
    {
        if (!handle)
            return handle;
        spin_rw_write_lock lock(m_mutex);
        auto found = colorprocmap.find(key);
        if (found == colorprocmap.end()) {
            // No equivalent item in the map. Add this one.
            colorprocmap[key] = handle;
            ++colorprocs_created;
        } else {
            // There's already an equivalent one. Oops. Discard this one and
            // return the one already in the map.
            handle = found->second;
        }
        return handle;
    }

    int getNumColorSpaces() const { return (int)colorspaces.size(); }

    const char* getColorSpaceNameByIndex(int index) const
    {
        return colorspaces[index].name.c_str();
    }

    string_view resolve(string_view name) const;

    // Note: Uses std::format syntax
    template<typename... Args>
    void error(const char* fmt, const Args&... args) const
    {
        spin_rw_write_lock lock(m_mutex);
        m_error = Strutil::fmt::format(fmt, args...);
    }
    std::string geterror(bool clear = true) const
    {
        std::string err;
        spin_rw_write_lock lock(m_mutex);
        if (clear) {
            std::swap(err, m_error);
        } else {
            err = m_error;
        }
        return err;
    }
    bool haserror() const
    {
        spin_rw_read_lock lock(m_mutex);
        return !m_error.empty();
    }
    void clear_error()
    {
        spin_rw_write_lock lock(m_mutex);
        m_error.clear();
    }

    std::vector<std::string> get_builtin_interop_ids() const;
    static OCIO::ConstConfigRcPtr build_interop_identities_config();
    string_view get_cached_equality_id(string_view colorspace) const;
    const std::vector<std::string>& getSimpleColorSpaces() const;

    const std::string& configfilename() const { return m_configfilename; }
    void configfilename(string_view filename) { m_configfilename = filename; }

    const std::string& configname() const { return m_configname; }
    void configname(string_view name) { m_configname = name; }

    OCIO::ConstCPUProcessorRcPtr
    get_to_builtin_cpu_proc(const char* my_from, const char* builtin_to) const;

    bool isColorSpaceLinear(string_view name) const;

private:
    void initialize_equality_id_map() const;

    // Return the CSInfo flags for the given color space name
    int flags(string_view name)
    {
        CSInfo* cs = find(name);
        if (!cs)
            return 0;
        examine(cs);
        spin_rw_read_lock lock(m_mutex);
        return cs->flags();
    }

    // Set cs.flag to include any bits in flagval.
    void setflag(CSInfo& cs, int flagval)
    {
        spin_rw_write_lock lock(m_mutex);
        cs.setflag(flagval);
    }

    // Set cs.flag to include any bits in flagval, and also if alias is not
    // yet set, set it to cs.name.
    void setflag(CSInfo& cs, int flagval, std::string& alias)
    {
        spin_rw_write_lock lock(m_mutex);
        cs.setflag(flagval, alias);
    }

    void inventory();

    // Set the flags for the given color space and canonical name, if we can
    // make a guess based on the name. This is very inexpensive. This should
    // only be called from within a lock of the mutex.
    void classify_by_name(CSInfo& cs);

    // Set the flags for the given color space and canonical name, trying some
    // tricks to deduce the color space from the primaries, white point, and
    // transfer function. This is more expensive, and might only work for OCIO
    // 2.2 and above. This should only be called from within a lock of the
    // mutex.
    void classify_by_conversions(CSInfo& cs);

    // Apply more heuristics to try to deduce more color space information.
    void reclassify_heuristics(CSInfo& cs);

    // If the CSInfo hasn't yet been "examined" (fully classified by all
    // heuristics), do so. This should NOT be called from within a lock of the
    // mutex.
    void examine(CSInfo* cs)
    {
        if (!cs->examined) {
            spin_rw_write_lock lock(m_mutex);
            if (!cs->examined) {
                classify_by_name(*cs);
                classify_by_conversions(*cs);
                reclassify_heuristics(*cs);
                cs->examined = true;
            }
        }
    }

    void debug_print_aliases()
    {
        DBG("Aliases: scene_linear={}   lin_srgb={}   srgb={}   ACEScg={}   Rec709={}\n",
            scene_linear_alias, lin_srgb_alias, srgb_alias, ACEScg_alias,
            Rec709_alias);
    }

    // For OCIO 2.3+, we can ask for the equivalent of some built-in
    // color spaces.
    void identify_builtin_equivalents();

    bool check_same_as_builtin_transform(const char* my_from,
                                         const char* builtin_to) const;
    bool test_conversion_yields(const char* from, const char* to,
                                cspan<Imath::C3f> test_colors,
                                cspan<Imath::C3f> result_colors) const;
    const char* IdentifyBuiltinColorSpace(const char* name) const;
};



// ColorConfig utility to take inventory of the color spaces available.
// It sets up knowledge of "linear", "srgb_rec709_scene", "Rec709", etc,
// even if the underlying OCIO configuration lacks them.
void
ColorConfig::Impl::inventory()
{
    DBG("inventorying config {}\n", configname());
    if (config_ && !disable_ocio) {
        bool nonraw = false;
        for (int i = 0, e = config_->getNumColorSpaces(); i < e; ++i) {
            auto csname = config_->getColorSpaceNameByIndex(i);
            auto cs     = (csname) ? config_->getColorSpace(c_str(csname))
                                   : nullptr;
            nonraw |= !cs->isData();  // prevent unused variable warning
        }
        if (nonraw) {
            for (int i = 0, e = config_->getNumColorSpaces(); i < e; ++i)
                add(config_->getColorSpaceNameByIndex(i), i);
            for (auto&& cs : colorspaces)
                classify_by_name(cs);
            OCIO::ConstColorSpaceRcPtr lin = config_->getColorSpace(
                "scene_linear");
            if (lin)
                scene_linear_alias = lin->getName();
            return;  // If any non-"raw" spaces were defined, we're done
        }
    }
    // If we had some kind of bogus configuration that seemed to define
    // only a "raw" color space and nothing else, that's useless, so
    // figure out our own way to move forward.
    config_.reset();

    // If there was no configuration, or we didn't compile with OCIO
    // support at all, register a few basic names we know about.
    // For the "no OCIO / no config" case, we assume an unsophisticated
    // color pipeline where "linear" and the like are all assumed to use
    // Rec709/sRGB color primaries.
    int linflags = CSInfo::is_linear_response | CSInfo::is_scene_linear
                   | CSInfo::is_lin_srgb;
    add("linear", 0, linflags);
    add("scene_linear", 0, linflags);
    add("default", 0, linflags);
    add("rgb", 0, linflags);
    add("RGB", 0, linflags);
    add("lin_rec709_scene", 0, linflags);
    add("lin_srgb", 0, linflags);
    add("lin_rec709", 0, linflags);
    add("srgb_rec709_scene", 1, CSInfo::is_srgb);
    add("sRGB", 1, CSInfo::is_srgb);
    add("Rec709", 2, CSInfo::is_Rec709);

    for (auto&& cs : colorspaces)
        classify_by_name(cs);
}



inline bool
close_colors(cspan<Imath::C3f> a, cspan<Imath::C3f> b)
{
    OIIO_DASSERT(a.size() == b.size());
    for (size_t i = 0, e = a.size(); i < e; ++i)
        if (std::abs(a[i].x - b[i].x) > 1.0e-3f
            || std::abs(a[i].y - b[i].y) > 1.0e-3f
            || std::abs(a[i].z - b[i].z) > 1.0e-3f)
            return false;
    return true;
}



OCIO::ConstCPUProcessorRcPtr
ColorConfig::Impl::get_to_builtin_cpu_proc(const char* my_from,
                                           const char* builtin_to) const
{
    try {
        auto proc = OCIO::Config::GetProcessorToBuiltinColorSpace(config_,
                                                                  my_from,
                                                                  builtin_to);
        return proc ? proc->getDefaultCPUProcessor()
                    : OCIO::ConstCPUProcessorRcPtr();
    } catch (...) {
        return {};
    }
}



// Is this config's `my_from` color space equivalent to the built-in
// `builtin_to` color space? Find out by transforming the primaries, white,
// and half white and see if the results indicate that it was the identity
// transform (or close enough).
bool
ColorConfig::Impl::check_same_as_builtin_transform(const char* my_from,
                                                   const char* builtin_to) const
{
    if (disable_builtin_configs)
        return false;
    auto proc = get_to_builtin_cpu_proc(my_from, builtin_to);
    if (proc) {
        Imath::C3f colors[n_test_colors];
        std::copy(test_colors, test_colors + n_test_colors, colors);
        proc->apply(OCIO::PackedImageDesc(colors, n_test_colors, 1, 3));
        if (close_colors(colors, test_colors))
            return true;
    }
    return false;
}



// If we transform test_colors from "from" to "to" space, do we get
// result_colors? This is a building block for deducing some color spaces.
bool
ColorConfig::Impl::test_conversion_yields(const char* from, const char* to,
                                          cspan<Imath::C3f> test_colors,
                                          cspan<Imath::C3f> result_colors) const
{
    auto proc = m_self->createColorProcessor(from, to);
    if (!proc)
        return false;
    OIIO_DASSERT(test_colors.size() == result_colors.size());
    auto n             = test_colors.size();
    Imath::C3f* colors = OIIO_ALLOCA(Imath::C3f, n);
    std::copy(test_colors.data(), test_colors.data() + n, colors);
    proc->apply((float*)colors, int(n), 1, 3, sizeof(float), 3 * sizeof(float),
                int(n) * 3 * sizeof(float));
    return close_colors({ colors, n }, result_colors);
}



static bool
transform_has_Lut3D(string_view name, OCIO::ConstTransformRcPtr transform,
                    OCIO::ConstConfigRcPtr config = nullptr)
{
    using namespace OCIO;
    auto ttype = transform ? transform->getTransformType() : -1;
    if (ttype == TRANSFORM_TYPE_LUT3D || ttype == TRANSFORM_TYPE_LOOK
        || ttype == TRANSFORM_TYPE_DISPLAY_VIEW) {
        return true;
    }
    if (ttype == TRANSFORM_TYPE_FILE) {
        // If the filename ends in ".spi1d" or ".spimtx", it's not a 3D LUT.
        auto filetransform = dynamic_cast<const FileTransform*>(
            transform.get());
        std::string src = filetransform->getSrc();
        Strutil::to_lower(src);
        if (!Strutil::ends_with(src, ".spi1d")
            && !Strutil::ends_with(src, ".spimtx"))
            return true;
    }
    if (ttype == TRANSFORM_TYPE_GROUP) {
        auto group = dynamic_cast<const GroupTransform*>(transform.get());
        for (int i = 0, n = group->getNumTransforms(); i < n; ++i) {
            if (transform_has_Lut3D(group->getFormatMetadata().getName(),
                                    group->getTransform(i), config))
                return true;
        }
    }
    if (ttype == TRANSFORM_TYPE_COLORSPACE) {
        if (!config)
            return false;

        auto cs_transform = dynamic_cast<const ColorSpaceTransform*>(
            transform.get());
        auto src = cs_transform->getSrc();
        auto dst = cs_transform->getDst();
        // Collect the transforms for source and destination color spaces

        if (!src && !dst)  // is reference space
            return false;

        if (!src || !dst) {  // is named transform
            auto nt = (src) ? config->getNamedTransform(c_str(src))
                            : config->getNamedTransform(c_str(dst));
            if (nt) {
                auto fwd_xform = nt->getTransform(TRANSFORM_DIR_FORWARD);
                if (fwd_xform
                    && transform_has_Lut3D(nt->getName(), fwd_xform, config))
                    return true;
            }
        }

        // collect source color space transforms
        auto ctx = config->getCurrentContext();

        auto src_cs = config->getColorSpace(ctx->resolveStringVar(c_str(src)));
        auto dst_cs = config->getColorSpace(ctx->resolveStringVar(c_str(dst)));
        auto src_to_ref   = src_cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
        auto src_from_ref = src_cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
        auto dst_to_ref   = dst_cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
        auto dst_from_ref = dst_cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
        if (src_to_ref)
            if (transform_has_Lut3D(name, src_to_ref, config))
                return true;
        if (dst_to_ref)
            if (transform_has_Lut3D(name, dst_to_ref, config))
                return true;
        if (src_from_ref)
            if (transform_has_Lut3D(name, src_from_ref, config))
                return true;
        if (dst_from_ref)
            if (transform_has_Lut3D(name, dst_from_ref, config))
                return true;
    }
    if (name.size() && ttype >= 0)
        DBG("{} has type {}\n", name, ttype);
    return false;
}



void
ColorConfig::Impl::classify_by_name(CSInfo& cs)
{
    // General heuristics based on the names -- for a few canonical names,
    // believe them! Woe be unto the poor soul who names a color space "sRGB"
    // or "ACEScg" and it's really something entirely different.
    if (Strutil::iequals(cs.name, "srgb_rec709_scene")
        || Strutil::iequals(cs.name, "srgb_tx")
        || Strutil::iequals(cs.name, "srgb_texture")
        || Strutil::iequals(cs.name, "srgb texture")
        || Strutil::iequals(cs.name, "srgb_rec709_scene")
        || Strutil::iequals(cs.name, "sRGB - Texture")
        || Strutil::iequals(cs.name, "sRGB")) {
        cs.setflag(CSInfo::is_srgb, srgb_alias);
    } else if (Strutil::iequals(cs.name, "lin_rec709_scene")
               || Strutil::iequals(cs.name, "lin_rec709")
               || Strutil::iequals(cs.name, "Linear Rec.709 (sRGB)")
               || Strutil::iequals(cs.name, "lin_srgb")
               || Strutil::iequals(cs.name, "linear")) {
        cs.setflag(CSInfo::is_lin_srgb | CSInfo::is_linear_response,
                   lin_srgb_alias);
    } else if (Strutil::iequals(cs.name, "ACEScg")
               || Strutil::iequals(cs.name, "lin_ap1_scene")
               || Strutil::iequals(cs.name, "lin_ap1")) {
        cs.setflag(CSInfo::is_ACEScg | CSInfo::is_linear_response,
                   ACEScg_alias);
    } else if (Strutil::iequals(cs.name, "Rec709")) {
        cs.setflag(CSInfo::is_Rec709, Rec709_alias);
    }
#ifdef OIIO_SITE_spi
    // Ugly SPI-specific hacks, so sorry
    else if (Strutil::starts_with(cs.name, "cgln")) {
        cs.setflag(CSInfo::is_ACEScg | CSInfo::is_linear_response,
                   ACEScg_alias);
    } else if (cs.name == "srgbf" || cs.name == "srgbh" || cs.name == "srgb16"
               || cs.name == "srgb8") {
        cs.setflag(CSInfo::is_srgb, srgb_alias);
    } else if (cs.name == "srgblnf" || cs.name == "srgblnh"
               || cs.name == "srgbln16" || cs.name == "srgbln8") {
        cs.setflag(CSInfo::is_lin_srgb, lin_srgb_alias);
    }
#endif

    // Set up some canonical names
    if (cs.flags() & CSInfo::is_srgb)
        cs.canonical = "srgb_rec709_scene";
    else if (cs.flags() & CSInfo::is_lin_srgb)
        cs.canonical = "lin_rec709_scene";
    else if (cs.flags() & CSInfo::is_ACEScg)
        cs.canonical = "lin_ap1_scene";
    else if (cs.flags() & CSInfo::is_Rec709)
        cs.canonical = "Rec709";
    if (cs.canonical.size()) {
        DBG("classify by name identified '{}' as canonical {}\n", cs.name,
            cs.canonical);
        cs.examined = true;
    }
}



void
ColorConfig::Impl::classify_by_conversions(CSInfo& cs)
{
    DBG("classifying by conversions {}\n", cs.name);
    if (cs.examined)
        return;  // Already classified

    if (isColorSpaceLinear(cs.name))
        cs.setflag(CSInfo::is_linear_response);

    // If the name didn't already tell us what it is, and we have a new enough
    // OCIO that has built-in configs, test whether this color space is
    // equivalent to one of a few particular built-in color spaces. That lets
    // us identify some color spaces even if they are named something
    // nonstandard. Skip this part if the color space we're classifying is
    // itself part of the built-in config -- in that case, it will already be
    // tagged correctly by the name above.
    if (!(cs.flags() & CSInfo::is_known) && config_ && !disable_ocio
        && !m_config_is_built_in) {
        using namespace OCIO;
        cs.ocio_cs = config_->getColorSpace(cs.name.c_str());
        if (transform_has_Lut3D(
                cs.name, cs.ocio_cs->getTransform(COLORSPACE_DIR_TO_REFERENCE),
                config_)
            || transform_has_Lut3D(cs.name,
                                   cs.ocio_cs->getTransform(
                                       COLORSPACE_DIR_FROM_REFERENCE),
                                   config_)) {
            // Skip things with LUT3d because they are expensive due to LUT
            // inversion costs, and they're not gonna be our favourite
            // canonical spaces anyway.
            // DBG("{} has LUT3\n", cs.name);
        } else if (check_same_as_builtin_transform(cs.name.c_str(), "srgb_tx")) {
            cs.setflag(CSInfo::is_srgb, srgb_alias);
        } else if (check_same_as_builtin_transform(cs.name.c_str(),
                                                   "lin_srgb")) {
            cs.setflag(CSInfo::is_lin_srgb | CSInfo::is_linear_response,
                       lin_srgb_alias);
        } else if (check_same_as_builtin_transform(cs.name.c_str(), "ACEScg")) {
            cs.setflag(CSInfo::is_ACEScg | CSInfo::is_linear_response,
                       ACEScg_alias);
        }
    }

    // Set up some canonical names
    if (cs.flags() & CSInfo::is_srgb)
        cs.canonical = "srgb_rec709_scene";
    else if (cs.flags() & CSInfo::is_lin_srgb)
        cs.canonical = "lin_rec709_scene";
    else if (cs.flags() & CSInfo::is_ACEScg)
        cs.canonical = "lin_ap1_scene";
    else if (cs.flags() & CSInfo::is_Rec709)
        cs.canonical = "Rec709";
}



void
ColorConfig::Impl::reclassify_heuristics(CSInfo& cs)
{
#if OCIO_VERSION_HEX < MAKE_OCIO_VERSION_HEX(2, 2, 0)
    // Extra checks for OCIO < 2.2. For >= 2.2, there is no need, we
    // already figured this out using the built-in configs.
    if (!(cs.flags() & CSInfo::is_known)) {
        // If this isn't one of the known color spaces, let's try some
        // tricks!
        static float srgb05 = linear_to_sRGB(0.5f);
        static Imath::C3f lin_srgb_to_srgb_results[n_test_colors]
            = { { 1, 0, 0 },
                { 0, 1, 0 },
                { 0, 0, 1 },
                { 1, 1, 1 },
                { srgb05, srgb05, srgb05 } };
        // If there is a known srgb space, and transforming our test
        // colors from "this cs" to srgb gives us what we expect for a
        // lin_srgb->srgb, then guess what? -- this is lin_srgb!
        if (srgb_alias.size()
            && test_conversion_yields(cs.name.c_str(), srgb_alias.c_str(),
                                      test_colors, lin_srgb_to_srgb_results)) {
            setflag(cs, CSInfo::is_lin_srgb | CSInfo::is_linear_response,
                    lin_srgb_alias);
            cs.canonical = "lin_srgb";
        }
    }
#endif
}



void
ColorConfig::Impl::identify_builtin_equivalents()
{
    if (disable_builtin_configs)
        return;
    Timer timer;
    if (auto n = IdentifyBuiltinColorSpace("srgb_tx")) {
        if (CSInfo* cs = find(n)) {
            cs->setflag(CSInfo::is_srgb, srgb_alias);
            DBG("Identified {} = builtin '{}'\n", "srgb_rec709_scene",
                cs->name);
        }
    } else {
        DBG("No config space identified as srgb\n");
    }
    DBG("identify_builtin_equivalents srgb took {:0.2f}s\n", timer.lap());
    if (auto n = IdentifyBuiltinColorSpace("lin_srgb")) {
        if (CSInfo* cs = find(n)) {
            cs->setflag(CSInfo::is_lin_srgb | CSInfo::is_linear_response,
                        lin_srgb_alias);
            DBG("Identified {} = builtin '{}'\n", "lin_rec709_scene", cs->name);
        }
    } else {
        DBG("No config space identified as lin_srgb\n");
    }
    DBG("identify_builtin_equivalents lin_srgb took {:0.2f}s\n", timer.lap());
    if (auto n = IdentifyBuiltinColorSpace("ACEScg")) {
        if (CSInfo* cs = find(n)) {
            cs->setflag(CSInfo::is_ACEScg | CSInfo::is_linear_response,
                        ACEScg_alias);
            DBG("Identified {} = builtin '{}'\n", "ACEScg", cs->name);
        }
    } else {
        DBG("No config space identified as acescg\n");
    }
    DBG("identify_builtin_equivalents acescg took {:0.2f}s\n", timer.lap());
}



const char*
ColorConfig::Impl::IdentifyBuiltinColorSpace(const char* name) const
{
    if (!config_ || disable_builtin_configs)
        return nullptr;
    try {
        return OCIO::Config::IdentifyBuiltinColorSpace(config_, interopconfig_,
                                                       name);
    } catch (...) {
    }
    try {
        return OCIO::Config::IdentifyBuiltinColorSpace(config_, builtinconfig_,
                                                       name);
    } catch (...) {
    }
    return nullptr;
}



ColorConfig::ColorConfig(string_view filename) { reset(filename); }



ColorConfig::~ColorConfig() {}



bool
ColorConfig::Impl::init(string_view filename)
{
    // High-level init flow:
    // - Load the OCIO config (or fall back to current/builtin).
    // - Build the built-in interop identities config (once) and adapt the
    //   working config to match its reference spaces.
    // - Clear per-config caches (processors, equality ids, fingerprints,
    //   simple color spaces, matchers).
    // - Inventory the config for roles/aliases and run heuristics.
    OIIO_MAYBE_UNUSED Timer timer;
    bool ok = true;

    m_equality_reverse_cache_enabled.store(!disable_equality_reverse_cache);

    auto oldlog = OCIO::GetLoggingLevel();
    OCIO::SetLoggingLevel(OCIO::LOGGING_LEVEL_NONE);

    try {
        builtinconfig_ = OCIO::Config::CreateFromFile("ocio://default");
    } catch (OCIO::Exception& e) {
        error("Error making OCIO built-in config: {}", e.what());
    }

    // create builtin interop identities config
    try {
        interopconfig_ = build_interop_identities_config();
    } catch (OCIO::Exception& e) {
        error("Error making OCIO interop identities config: {}", e.what());
    }

    // If no filename was specified, use env $OCIO
    if (filename.empty() || Strutil::iequals(filename, "$OCIO"))
        filename = Sysutil::getenv("OCIO");
    if (filename.empty())
        filename = "ocio://default";
    // If there's a newline in filename, treat it as the config data itself
    if (filename.find('\n') != string_view::npos) {
        try {
            std::istringstream iss;
            iss.str(std::string(filename));
            config_   = OCIO::Config::CreateFromStream(iss);
            auto name = config_->getName();
            if (name && name[0])
                configname(name);
            else
                configname(config_->getCacheID());
            configfilename(filename);  // from stream, no filename
        } catch (OCIO::Exception& e) {
            error("Error reading OCIO config from stream: {}", e.what());
        }
    }
    if (filename.size() && !OIIO::Filesystem::exists(filename)
        && !Strutil::istarts_with(filename, "ocio://")) {
        error("Requested non-existent OCIO config \"{}\"", filename);
    } else {
        // Either filename passed, or taken from $OCIO, and it seems to exist
        try {
            config_ = OCIO::Config::CreateFromFile(
                std::string(filename).c_str());
            configname(filename);
            configfilename(filename);
            m_config_is_built_in = Strutil::istarts_with(filename, "ocio://");
        } catch (OCIO::Exception& e) {
            error("Error reading OCIO config \"{}\": {}", filename, e.what());
        }
    }

    if (!config_) {
        OCIO::LogMessage(OCIO::LOGGING_LEVEL_DEBUG,
                         "Falling back to current OCIO config");
        auto current_config = OCIO::GetCurrentConfig();
        if (current_config->getNumColorSpaces() == 1) {
            config_ = OCIO::Config::CreateFromFile("ocio://default");
            configname("ocio://default");
            configfilename("ocio://default");
            OCIO::LogMessage(
                OCIO::LOGGING_LEVEL_DEBUG,
                "Current OCIO config is invalid, using ocio://default "
                "instead");
            OCIO::SetCurrentConfig(config_);
        } else
            config_ = current_config;
        auto config_name = current_config->getName();
        configname(config_name ? config_name : "current");
        configfilename("current");
    }

    if (config_ && interopconfig_) {
        try {
            config_ = ConfigUtils::adaptConfigReferenceSpaces(config_,
                                                              interopconfig_);
        } catch (OCIO::Exception& e) {
            error("Error adapting OCIO config to interop reference spaces: {}",
                  e.what());
        }
    }

    OCIO::SetLoggingLevel(oldlog);

    ok = config_.get() != nullptr;

    DBG("OCIO config {} loaded in {:0.2f} seconds\n", filename, timer.lap());

    {
        spin_rw_write_lock lock(m_mutex);
        // Equality-ID caches are per context cache ID.
        m_equality_id_to_cs_by_ctx.clear();
        m_cs_to_equality_id_by_ctx.clear();
        m_equality_map_initialized_ctx.clear();
        // Simple colorspaces are prefiltered to avoid expensive transforms.
        m_simple_color_spaces_cache.clear();
        m_simple_color_spaces_cached = false;
        // Matcher uses cached fingerprints and is rebuilt per config.
        std::lock_guard<std::mutex> matcher_lock(m_interop_matcher_mutex);
        m_interop_matcher.reset();
    }
    {
        std::lock_guard<std::mutex> lock(m_fingerprint_cache_mutex);
        // Fingerprints are keyed by config+context cache ID.
        m_fingerprint_cache.clear();
    }

    inventory();
    // NOTE: inventory already does classify_by_name

    DBG("\nIDENTIFY BUILTIN EQUIVALENTS\n");
    identify_builtin_equivalents();  // OCIO 2.3+ only
    DBG("OCIO 2.3+ builtin equivalents in {:0.2f} seconds\n", timer.lap());

#if 1
    for (auto&& cs : colorspaces) {
        // examine(&cs);
        DBG("Color space '{}':\n", cs.name);
        if (cs.flags() & CSInfo::is_srgb)
            DBG("'{}' is srgb\n", cs.name);
        if (cs.flags() & CSInfo::is_lin_srgb)
            DBG("'{}' is lin_srgb\n", cs.name);
        if (cs.flags() & CSInfo::is_ACEScg)
            DBG("'{}' is ACEScg\n", cs.name);
        if (cs.flags() & CSInfo::is_Rec709)
            DBG("'{}' is Rec709\n", cs.name);
        if (cs.flags() & CSInfo::is_linear_response)
            DBG("'{}' has linear response\n", cs.name);
        if (cs.flags() & CSInfo::is_scene_linear)
            DBG("'{}' is scene_linear\n", cs.name);
        if (cs.flags())
            DBG("\n");
    }
#endif
    debug_print_aliases();
    DBG("OCIO config {} classified in {:0.2f} seconds\n", filename,
        timer.lap());
    return ok;
}



bool
ColorConfig::reset(string_view filename)
{
    OIIO::pvt::LoggedTimer logtime("ColorConfig::reset");
    if (m_impl
        && (filename == getImpl()->configname()
            || (filename == ""
                && getImpl()->configname() == "ocio://default"))) {
        // Request to reset to the config we're already using. Just return,
        // don't do anything expensive.
        return true;
    }

    m_impl.reset(new ColorConfig::Impl(this));
    return m_impl->init(filename);
}



bool
ColorConfig::has_error() const
{
    return (getImpl()->haserror());
}



std::string
ColorConfig::geterror(bool clear) const
{
    return getImpl()->geterror(clear);
}



int
ColorConfig::getNumColorSpaces() const
{
    return (int)getImpl()->getNumColorSpaces();
}



const char*
ColorConfig::getColorSpaceNameByIndex(int index) const
{
    return getImpl()->getColorSpaceNameByIndex(index);
}



int
ColorConfig::getColorSpaceIndex(string_view name) const
{
    // Check for exact matches
    for (int i = 0, e = getNumColorSpaces(); i < e; ++i)
        if (Strutil::iequals(getColorSpaceNameByIndex(i), name))
            return i;
    // Check for aliases and equivalents
    for (int i = 0, e = getNumColorSpaces(); i < e; ++i)
        if (equivalent(getColorSpaceNameByIndex(i), name))
            return i;
    return -1;
}



const char*
ColorConfig::getColorSpaceFamilyByName(string_view name) const
{
    if (getImpl()->config_ && !disable_ocio) {
        OCIO::ConstColorSpaceRcPtr c = getImpl()->config_->getColorSpace(
            std::string(name).c_str());
        if (c)
            return c->getFamily();
    }
    return nullptr;
}



std::vector<std::string>
ColorConfig::getColorSpaceNames() const
{
    std::vector<std::string> result;
    int n = getNumColorSpaces();
    result.reserve(n);
    for (int i = 0; i < n; ++i)
        result.emplace_back(getColorSpaceNameByIndex(i));
    return result;
}

std::vector<std::string>
ColorConfig::getColorSpaceNamesFiltered(bool active, bool inactive, bool scene,
                                        bool display, bool simple) const
{
    std::vector<std::string> result;
    if (disable_ocio || !getImpl()->config_)
        return result;

    if (!active && !inactive)
        return result;
    if (!scene && !display)
        return result;

    OCIO::ColorSpaceVisibility visibility = OCIO::COLORSPACE_ALL;
    if (active && !inactive)
        visibility = OCIO::COLORSPACE_ACTIVE;
    else if (!active && inactive)
        visibility = OCIO::COLORSPACE_INACTIVE;

    OCIO::SearchReferenceSpaceType refspace = OCIO::SEARCH_REFERENCE_SPACE_ALL;
    if (scene && !display)
        refspace = OCIO::SEARCH_REFERENCE_SPACE_SCENE;
    else if (!scene && display)
        refspace = OCIO::SEARCH_REFERENCE_SPACE_DISPLAY;

    const std::vector<std::string>* simple_spaces = nullptr;
    if (simple)
        simple_spaces = &getImpl()->getSimpleColorSpaces();

    const int n = getImpl()->config_->getNumColorSpaces(refspace, visibility);
    result.reserve(n);
    for (int i = 0; i < n; ++i) {
        const char* name
            = getImpl()->config_->getColorSpaceNameByIndex(refspace, visibility,
                                                           i);
        if (name && *name) {
            if (simple
                && !std::binary_search(simple_spaces->begin(),
                                       simple_spaces->end(), name))
                continue;
            result.emplace_back(name);
        }
    }
    return result;
}

int
ColorConfig::getNumRoles() const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNumRoles();
    return 0;
}

const char*
ColorConfig::getRoleByIndex(int index) const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getRoleName(index);
    return nullptr;
}


std::vector<std::string>
ColorConfig::getRoles() const
{
    std::vector<std::string> result;
    for (int i = 0, e = getNumRoles(); i != e; ++i)
        result.emplace_back(getRoleByIndex(i));
    return result;
}



int
ColorConfig::getNumLooks() const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNumLooks();
    return 0;
}



const char*
ColorConfig::getLookNameByIndex(int index) const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getLookNameByIndex(index);
    return nullptr;
}



std::vector<std::string>
ColorConfig::getLookNames() const
{
    std::vector<std::string> result;
    for (int i = 0, e = getNumLooks(); i != e; ++i)
        result.emplace_back(getLookNameByIndex(i));
    return result;
}



bool
ColorConfig::isColorSpaceLinear(string_view name) const
{
    return getImpl()->isColorSpaceLinear(name);
}



bool
ColorConfig::Impl::isColorSpaceLinear(string_view name) const
{
    if (config_ && !disable_builtin_configs && !disable_ocio) {
        try {
            return config_->isColorSpaceLinear(c_str(name),
                                               OCIO::REFERENCE_SPACE_SCENE)
                   || config_->isColorSpaceLinear(c_str(name),
                                                  OCIO::REFERENCE_SPACE_DISPLAY);
        } catch (const std::exception& e) {
            error("ColorConfig error: {}", e.what());
            return false;
        }
    }
    return Strutil::iequals(name, "linear")
           || Strutil::istarts_with(name, "linear ")
           || Strutil::istarts_with(name, "linear_")
           || Strutil::istarts_with(name, "lin_")
           || Strutil::iends_with(name, "_linear")
           || Strutil::iends_with(name, "_lin");
}



std::vector<std::string>
ColorConfig::getAliases(string_view color_space) const
{
    std::vector<std::string> result;
    auto config = getImpl()->config_;
    if (config) {
        auto cs = config->getColorSpace(c_str(color_space));
        if (cs) {
            for (int i = 0, e = cs->getNumAliases(); i < e; ++i)
                result.emplace_back(cs->getAlias(i));
        }
    }
    return result;
}



const char*
ColorConfig::getColorSpaceNameByRole(string_view role) const
{
    if (getImpl()->config_ && !disable_ocio) {
        using Strutil::print;
        OCIO::ConstColorSpaceRcPtr c = getImpl()->config_->getColorSpace(
            std::string(role).c_str());
        // DBG("looking first for named color space {} -> {}\n", role,
        //     c ? c->getName() : "not found");
        // Catch special case of obvious name synonyms
        if (!c
            && (Strutil::iequals(role, "RGB")
                || Strutil::iequals(role, "default")))
            role = string_view("linear");
        if (!c && Strutil::iequals(role, "linear"))
            c = getImpl()->config_->getColorSpace("scene_linear");
        if (!c && Strutil::iequals(role, "scene_linear"))
            c = getImpl()->config_->getColorSpace("linear");
        if (!c && Strutil::iequals(role, "srgb")) {
            c = getImpl()->config_->getColorSpace("sRGB - Texture");
            // DBG("Unilaterally substituting {} -> '{}'\n", role,
            //                c->getName());
        }

        if (c) {
            // DBG("found color space {} for role {}\n", c->getName(),
            //                role);
            return c->getName();
        }
    }

    // No OCIO at build time, or no OCIO configuration at run time
    if (Strutil::iequals(role, "linear")
        || Strutil::iequals(role, "scene_linear"))
        return "linear";

    return NULL;  // Dunno what role
}



TypeDesc
ColorConfig::getColorSpaceDataType(string_view name, int* bits) const
{
    if (getImpl()->config_ && !disable_ocio) {
        OCIO::ConstColorSpaceRcPtr c = getImpl()->config_->getColorSpace(
            std::string(name).c_str());
        if (c) {
            OCIO::BitDepth b = c->getBitDepth();
            switch (b) {
            case OCIO::BIT_DEPTH_UNKNOWN: return TypeDesc::UNKNOWN;
            case OCIO::BIT_DEPTH_UINT8: *bits = 8; return TypeDesc::UINT8;
            case OCIO::BIT_DEPTH_UINT10: *bits = 10; return TypeDesc::UINT16;
            case OCIO::BIT_DEPTH_UINT12: *bits = 12; return TypeDesc::UINT16;
            case OCIO::BIT_DEPTH_UINT14: *bits = 14; return TypeDesc::UINT16;
            case OCIO::BIT_DEPTH_UINT16: *bits = 16; return TypeDesc::UINT16;
            case OCIO::BIT_DEPTH_UINT32: *bits = 32; return TypeDesc::UINT32;
            case OCIO::BIT_DEPTH_F16: *bits = 16; return TypeDesc::HALF;
            case OCIO::BIT_DEPTH_F32: *bits = 32; return TypeDesc::FLOAT;
            }
        }
    }
    return TypeUnknown;
}



int
ColorConfig::getNumDisplays() const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNumDisplays();
    return 0;
}



const char*
ColorConfig::getDisplayNameByIndex(int index) const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getDisplay(index);
    return nullptr;
}



std::vector<std::string>
ColorConfig::getDisplayNames() const
{
    std::vector<std::string> result;
    for (int i = 0, e = getNumDisplays(); i != e; ++i)
        result.emplace_back(getDisplayNameByIndex(i));
    return result;
}



int
ColorConfig::getNumViews(string_view display) const
{
    if (display.empty())
        display = getDefaultDisplayName();
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNumViews(std::string(display).c_str());
    return 0;
}



const char*
ColorConfig::getViewNameByIndex(string_view display, int index) const
{
    if (display.empty())
        display = getDefaultDisplayName();
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getView(std::string(display).c_str(), index);
    return nullptr;
}



std::vector<std::string>
ColorConfig::getViewNames(string_view display) const
{
    std::vector<std::string> result;
    if (display.empty())
        display = getDefaultDisplayName();
    for (int i = 0, e = getNumViews(display); i != e; ++i)
        result.emplace_back(getViewNameByIndex(display, i));
    return result;
}



const char*
ColorConfig::getDefaultDisplayName() const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getDefaultDisplay();
    return nullptr;
}



const char*
ColorConfig::getDefaultViewName(string_view display) const
{
    if (display.empty() || display == "default")
        display = getDefaultDisplayName();
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getDefaultView(c_str(display));
    return nullptr;
}


const char*
ColorConfig::getDefaultViewName(string_view display,
                                string_view inputColorSpace) const
{
    if (display.empty() || display == "default")
        display = getDefaultDisplayName();
    if (inputColorSpace.empty() || inputColorSpace == "default")
        inputColorSpace = getImpl()->config_->getColorSpaceFromFilepath(
            c_str(inputColorSpace));
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getDefaultView(c_str(display),
                                                  c_str(inputColorSpace));
    return nullptr;
}


const char*
ColorConfig::getDisplayViewColorSpaceName(const std::string& display,
                                          const std::string& view) const
{
    if (getImpl()->config_ && !disable_ocio) {
        string_view name
            = getImpl()->config_->getDisplayViewColorSpaceName(c_str(display),
                                                               c_str(view));
        // Handle certain Shared View cases
        if (strcmp(c_str(name), "<USE_DISPLAY_NAME>") == 0)
            name = display;
        return c_str(name);
    }
    return nullptr;
}



const char*
ColorConfig::getDisplayViewLooks(const std::string& display,
                                 const std::string& view) const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getDisplayViewLooks(display.c_str(),
                                                       view.c_str());
    return nullptr;
}



int
ColorConfig::getNumNamedTransforms() const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNumNamedTransforms();
    return 0;
}



const char*
ColorConfig::getNamedTransformNameByIndex(int index) const
{
    if (getImpl()->config_ && !disable_ocio)
        return getImpl()->config_->getNamedTransformNameByIndex(index);
    return nullptr;
}



std::vector<std::string>
ColorConfig::getNamedTransformNames() const
{
    std::vector<std::string> result;
    for (int i = 0, e = getNumNamedTransforms(); i != e; ++i)
        result.emplace_back(getNamedTransformNameByIndex(i));
    return result;
}



std::vector<std::string>
ColorConfig::getNamedTransformAliases(string_view named_transform) const
{
    std::vector<std::string> result;
    auto config = getImpl()->config_;
    if (config) {
        auto nt = config->getNamedTransform(c_str(named_transform));
        if (nt) {
            for (int i = 0, e = nt->getNumAliases(); i < e; ++i)
                result.emplace_back(nt->getAlias(i));
        }
    }
    return result;
}



std::string
ColorConfig::configname() const
{
    // If configfilename() has newlines in it,
    // it's actually the config data as a string.
    // In that case, return the OCIO config name or cache ID.
    std::string fname = getImpl()->configfilename();
    if (fname.find('\n') != std::string::npos) {
        return ocioconfigname();
    }
    return fname;
}



std::string
ColorConfig::configfilename() const
{
    return getImpl()->configfilename();
}



std::string
ColorConfig::ocioconfigname() const
{
    // If the OCIO config has a non-empty name, return that.
    // Otherwise, return its cache ID.
    auto name = getImpl()->config_->getName();
    if (name && name[0])
        return name;
    return getImpl()->config_->getCacheID();
}

std::string
ColorConfig::getName() const
{
    auto config = getImpl()->config_;
    if (!config)
        return {};
    const char* name = config->getName();
    return name ? std::string(name) : std::string();
}

std::string
ColorConfig::getCacheID() const
{
    auto config = getImpl()->config_;
    if (!config)
        return {};
    const char* id = config->getCacheID();
    return id ? std::string(id) : std::string();
}

std::string
ColorConfig::getWorkingDir() const
{
    auto config = getImpl()->config_;
    if (!config)
        return {};
    const char* dir = config->getWorkingDir();
    return dir ? std::string(dir) : std::string();
}

void
ColorConfig::setWorkingDir(string_view dir)
{
    auto impl   = getImpl();
    auto config = impl->config_;
    if (!config)
        return;
    OCIO::ConfigRcPtr editable = config->createEditableCopy();
    editable->setWorkingDir(c_str(dir));
    impl->config_ = editable;
    // Processor cache does not include config cacheID, so reset it.
    impl->clear_colorproc_cache();
}



string_view
ColorConfig::resolve(string_view name) const
{
    return getImpl()->resolve(name);
}

string_view
ColorConfig::resolve(string_view name, string_view default_value) const
{
    string_view resolved = resolve(name);
    if (resolved == name) {
        if (!color_space_exists(name))
            return default_value;
        return name;
    }
    return resolved;
}

std::string
ColorConfig::getCanonicalName(string_view name) const
{
    auto config = getImpl()->config_;
    if (!config)
        return {};
    const char* canonical = config->getCanonicalName(c_str(name));
    return (canonical && *canonical) ? std::string(canonical) : std::string();
}

bool
ColorConfig::color_space_exists(string_view cs_name) const
{
    auto config = getImpl()->config_;
    if (!config)
        return false;
    string_view resolved = resolve(cs_name);
    return !resolved.empty()
           && config->getColorSpace(c_str(resolved)) != nullptr;
}

std::vector<std::string>
ColorConfig::get_builtin_interop_ids() const
{
    return getImpl()->get_builtin_interop_ids();
}



OCIO::ConstConfigRcPtr
ColorConfig::Impl::build_interop_identities_config()
{
    static OCIO::ConstConfigRcPtr s_interop_identities_config =
        []() -> OCIO::ConstConfigRcPtr {
        std::istringstream iss(kInteropIdentitiesConfig);
        auto oiio_interop_identities = OCIO::Config::CreateFromStream(iss);
        // TODO: Use config merger API for OCIO-2.5+
        return oiio_interop_identities;
    }();
    return s_interop_identities_config;
}


std::vector<std::string>
ColorConfig::Impl::get_builtin_interop_ids() const
{
    std::vector<std::string> ids;
    if (interopconfig_) {
        const auto refspace   = OCIO::SEARCH_REFERENCE_SPACE_ALL;
        const auto visibility = OCIO::COLORSPACE_ACTIVE;
        for (int i = 0,
                 e = interopconfig_->getNumColorSpaces(refspace, visibility);
             i < e; ++i) {
            const char* name
                = interopconfig_->getColorSpaceNameByIndex(refspace, visibility,
                                                           i);
            if (!(name && *name))
                continue;
#if OCIO_VERSION_HEX >= MAKE_OCIO_VERSION_HEX(2, 5, 0)
            auto cs = interopconfig_->getColorSpace(name);
            if (!cs)
                continue;
            const char* interop = cs->getInteropID();
            if (interop && *interop)
                ids.emplace_back(interop);
#else
            ids.emplace_back(name);
#endif
        }
    }
    // Keep unnamespaced IDs (no ':') before namespaced IDs, while sorting
    // alphabetically within each group for stable/readable output.
    auto by_name = [](const std::string& a, const std::string& b) {
        const bool a_has_colon = a.find(':') != std::string::npos;
        const bool b_has_colon = b.find(':') != std::string::npos;
        if (a_has_colon != b_has_colon)
            return !a_has_colon;
        return a < b;
    };
    std::sort(ids.begin(), ids.end(), by_name);
    ids.erase(std::unique(ids.begin(), ids.end()), ids.end());
    // Force fallback IDs to the tail in a stable order.
    ids.erase(std::remove(ids.begin(), ids.end(), "data"), ids.end());
    ids.erase(std::remove(ids.begin(), ids.end(), "unknown"), ids.end());
    ids.emplace_back("data");
    ids.emplace_back("unknown");
    return ids;
}

string_view
ColorConfig::Impl::resolve(string_view name) const
{
    const char* namestr = c_str(name);
    auto cs             = config_->getColorSpace(namestr);
    if (cs)
        return cs->getName();

    // OCIO did not know this name as a color space, role, or alias.
    initialize_equality_id_map();
    {
        OCIO::ConstContextRcPtr ctx = config_ ? config_->getCurrentContext()
                                              : nullptr;
        const std::string key       = equality_cache_key(config_, ctx);
        spin_rw_read_lock lock(m_mutex);
        auto it_ctx = m_equality_id_to_cs_by_ctx.find(key);
        if (m_equality_reverse_cache_enabled.load()
            && it_ctx != m_equality_id_to_cs_by_ctx.end()) {
            auto it = it_ctx->second.find(std::string(name));
            if (it != it_ctx->second.end())
                return it->second;
        }
    }

    spin_rw_write_lock lock(m_mutex);

    // Check the interop identities config as well...
    auto builtin_cs = interopconfig_->getColorSpace(namestr);
    if (builtin_cs) {
        try {
            const char* equivalent_cs = OCIO::Config::IdentifyBuiltinColorSpace(
                config_, interopconfig_, builtin_cs->getName());
            if (equivalent_cs && *equivalent_cs)
                return equivalent_cs;
        } catch (OCIO::Exception& e) {
            // ignore
        }
    }

    // Maybe it's an informal alias of common names?
    if ((Strutil::iequals(name, "sRGB")
         || Strutil::iequals(name, "srgb_rec709_scene"))
        && !srgb_alias.empty())
        return srgb_alias;
    if ((Strutil::iequals(name, "lin_srgb")
         || Strutil::iequals(name, "lin_rec709")
         || Strutil::iequals(name, "lin_rec709_scene")
         || Strutil::iequals(name, "linear"))
        && lin_srgb_alias.size())
        return lin_srgb_alias;
    if ((Strutil::iequals(name, "ACEScg")
         || Strutil::iequals(name, "lin_ap1_scene"))
        && !ACEScg_alias.empty())
        return ACEScg_alias;
    if (Strutil::iequals(name, "scene_linear") && !scene_linear_alias.empty()) {
        return scene_linear_alias;
    }
    if (Strutil::iequals(name, "Rec709") && Rec709_alias.size())
        return Rec709_alias;

    return name;
}



bool
ColorConfig::equivalent(string_view color_space1,
                        string_view color_space2) const
{
    // Empty color spaces never match
    if (color_space1.empty() || color_space2.empty())
        return false;
    // Easy case: matching names are the same!
    if (Strutil::iequals(color_space1, color_space2))
        return true;

    // If "resolved" names (after converting aliases and roles to color
    // spaces) match, they are equivalent.
    color_space1 = resolve(color_space1);
    color_space2 = resolve(color_space2);
    if (color_space1.empty() || color_space2.empty())
        return false;
    if (Strutil::iequals(color_space1, color_space2))
        return true;

    // If the color spaces' flags (when masking only the bits that refer to
    // specific known color spaces) match, consider them equivalent.
    const int mask = CSInfo::is_srgb | CSInfo::is_lin_srgb | CSInfo::is_ACEScg
                     | CSInfo::is_Rec709;
    const CSInfo* csi1 = getImpl()->find(color_space1);
    const CSInfo* csi2 = getImpl()->find(color_space2);
    if (csi1 && csi2) {
        int flags1 = csi1->flags() & mask;
        int flags2 = csi2->flags() & mask;
        if ((flags1 | flags2) && csi1->flags() == csi2->flags())
            return true;
        if ((csi1->canonical.size() && csi2->canonical.size())
            && Strutil::iequals(csi1->canonical, csi2->canonical))
            return true;
    }

    return false;
}



bool
equivalent_colorspace(string_view a, string_view b)
{
    return ColorConfig::default_colorconfig().equivalent(a, b);
}



inline OCIO::BitDepth
ocio_bitdepth(TypeDesc type)
{
    if (type == TypeDesc::UINT8)
        return OCIO::BIT_DEPTH_UINT8;
    if (type == TypeDesc::UINT16)
        return OCIO::BIT_DEPTH_UINT16;
    if (type == TypeDesc::UINT32)
        return OCIO::BIT_DEPTH_UINT32;
    // N.B.: OCIOv2 also supports 10, 12, and 14 bit int, but we won't
    // ever have data in that format at this stage.
    if (type == TypeDesc::HALF)
        return OCIO::BIT_DEPTH_F16;
    if (type == TypeDesc::FLOAT)
        return OCIO::BIT_DEPTH_F32;
    return OCIO::BIT_DEPTH_UNKNOWN;
}



// Custom ColorProcessor that wraps an OpenColorIO Processor.
class ColorProcessor_OCIO final : public ColorProcessor {
public:
    ColorProcessor_OCIO(OCIO::ConstProcessorRcPtr p)
        : m_p(p)
        , m_cpuproc(p->getDefaultCPUProcessor())
    {
    }
    ~ColorProcessor_OCIO() override {}

    bool isNoOp() const override { return m_p->isNoOp(); }
    bool hasChannelCrosstalk() const override
    {
        return m_p->hasChannelCrosstalk();
    }
    void apply(float* data, int width, int height, int channels,
               stride_t chanstride, stride_t xstride,
               stride_t ystride) const override
    {
        OCIO::PackedImageDesc pid(data, width, height, channels,
                                  OCIO::BIT_DEPTH_F32,  // For now, only float
                                  chanstride, xstride, ystride);
        m_cpuproc->apply(pid);
    }

private:
    OCIO::ConstProcessorRcPtr m_p;
    OCIO::ConstCPUProcessorRcPtr m_cpuproc;
};



// ColorProcessor that implements a matrix multiply color transformation.
class ColorProcessor_Matrix final : public ColorProcessor {
public:
    ColorProcessor_Matrix(const Imath::M44f& Matrix, bool inverse)
        : ColorProcessor()
        , m_M(Matrix)
    {
        if (inverse)
            m_M = m_M.inverse();
    }
    ~ColorProcessor_Matrix() override {}

    void apply(float* data, int width, int height, int channels,
               stride_t chanstride, stride_t xstride,
               stride_t ystride) const override
    {
        using namespace simd;
        if (channels == 3 && chanstride == sizeof(float)) {
            for (int y = 0; y < height; ++y) {
                char* d = (char*)data + y * ystride;
                for (int x = 0; x < width; ++x, d += xstride) {
                    vfloat4 color;
                    color.load((float*)d, 3);
                    vfloat4 xcolor = color * m_M;
                    xcolor.store((float*)d, 3);
                }
            }
        } else if (channels >= 4 && chanstride == sizeof(float)) {
            for (int y = 0; y < height; ++y) {
                char* d = (char*)data + y * ystride;
                for (int x = 0; x < width; ++x, d += xstride) {
                    vfloat4 color;
                    color.load((float*)d);
                    vfloat4 xcolor = color * m_M;
                    xcolor.store((float*)d);
                }
            }
        } else {
            channels = std::min(channels, 4);
            for (int y = 0; y < height; ++y) {
                char* d = (char*)data + y * ystride;
                for (int x = 0; x < width; ++x, d += xstride) {
                    vfloat4 color;
                    char* dc = d;
                    for (int c = 0; c < channels; ++c, dc += chanstride)
                        color[c] = *(float*)dc;
                    vfloat4 xcolor = color * m_M;
                    for (int c = 0; c < channels; ++c, dc += chanstride)
                        *(float*)dc = xcolor[c];
                }
            }
        }
    }

private:
    simd::matrix44 m_M;
};



ColorProcessorHandle
ColorConfig::createColorProcessor(string_view inputColorSpace,
                                  string_view outputColorSpace,
                                  string_view context_key,
                                  string_view context_value) const
{
    return createColorProcessor(ustring(inputColorSpace),
                                ustring(outputColorSpace), ustring(context_key),
                                ustring(context_value));
}



ColorProcessorHandle
ColorConfig::createColorProcessor(ustring inputColorSpace,
                                  ustring outputColorSpace, ustring context_key,
                                  ustring context_value) const
{
    std::string pending_error;

    // First, look up the requested processor in the cache. If it already
    // exists, just return it.
    ColorProcCacheKey prockey(inputColorSpace, outputColorSpace, context_key,
                              context_value);
    ColorProcessorHandle handle = getImpl()->findproc(prockey);
    if (handle)
        return handle;

    // DBG("createColorProcessor {} -> {}\n", inputColorSpace,
    //                outputColorSpace);
    // Ask OCIO to make a Processor that can handle the requested
    // transformation.
    OCIO::ConstProcessorRcPtr p;
    if (getImpl()->config_ && !disable_ocio) {
        // DBG("after role substitution, {} -> {}\n", inputColorSpace,
        //                outputColorSpace);
        auto config  = getImpl()->config_;
        auto context = config->getCurrentContext();
        auto keys    = Strutil::splits(context_key, ",");
        auto values  = Strutil::splits(context_value, ",");
        if (keys.size() && values.size() && keys.size() == values.size()) {
            OCIO::ContextRcPtr ctx = context->createEditableCopy();
            for (size_t i = 0; i < keys.size(); ++i)
                ctx->setStringVar(keys[i].c_str(), values[i].c_str());
            context = ctx;
        }

        // If either the input or output color spaces are in the known
        // builtin interop identities, and not in the current config,
        // create a processor that goes through the interop config.
        auto builtin_ids = getImpl()->get_builtin_interop_ids();
        bool use_interop = false;
        bool input_matches_builtin_interop_id  = false;
        bool output_matches_builtin_interop_id = false;
        bool input_in_current_config           = true;
        bool output_in_current_config          = true;

        auto cs_in = config->getColorSpace(c_str(inputColorSpace));

        if (!cs_in) {
            input_in_current_config = false;
            if (getImpl()->interopconfig_->getColorSpace(
                    c_str(inputColorSpace))) {
                // DBG("Input color space '{}' found in interop config\n",
                //                inputColorSpace);
                input_matches_builtin_interop_id = true;
            }
        }
        auto cs_out = config->getColorSpace(c_str(outputColorSpace));
        if (!cs_out) {
            output_in_current_config = false;
            if (getImpl()->interopconfig_->getColorSpace(
                    c_str(outputColorSpace))) {
                // DBG("Output color space '{}' found in interop config\n",
                //                outputColorSpace);
                output_matches_builtin_interop_id = true;
            }
        }
        use_interop = (input_matches_builtin_interop_id
                       || output_matches_builtin_interop_id)
                      && (!input_in_current_config
                          || !output_in_current_config);

        if (use_interop) {
            auto interop_config = getImpl()->interopconfig_;
            auto src_config     = config;
            auto dst_config     = config;
            if (input_matches_builtin_interop_id)
                src_config = interop_config;
            if (output_matches_builtin_interop_id)
                dst_config = interop_config;
            try {
                p = OCIO::Config::GetProcessorFromConfigs(
                    context, src_config, c_str(inputColorSpace), context,
                    dst_config, c_str(outputColorSpace));
                getImpl()->clear_error();
            } catch (OCIO::Exception& e) {
                // Don't quit yet, remember the error and see if any of our
                // built-in knowledge of some generic spaces will save us.
                p.reset();
                pending_error = e.what();
            } catch (...) {
                p.reset();
                getImpl()->error(
                    "An unknown error occurred in OpenColorIO, getProcessor");
            }
        } else {
            inputColorSpace  = ustring(inputColorSpace);
            outputColorSpace = ustring(outputColorSpace);

            try {
                // Get the processor corresponding to this transform.
                p = getImpl()->config_->getProcessor(context,
                                                     inputColorSpace.c_str(),
                                                     outputColorSpace.c_str());
                getImpl()->clear_error();
                // DBG("Created OCIO processor '{}' -> '{}'\n",
                //                inputColorSpace, outputColorSpace);
            } catch (OCIO::Exception& e) {
                // Don't quit yet, remember the error and see if any of our
                // built-in knowledge of some generic spaces will save us.
                p.reset();
                pending_error = e.what();
                // DBG("FAILED to create OCIO processor '{}' -> '{}'\n",
                //                inputColorSpace, outputColorSpace);
            } catch (...) {
                p.reset();
                getImpl()->error(
                    "An unknown error occurred in OpenColorIO, getProcessor");
            }
        }
        if (p && !p->isNoOp()) {
            // If we got a valid processor that does something useful,
            // return it now. If it boils down to a no-op, give a second
            // chance below to recognize it as a special case.
            handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
            // DBG("OCIO processor '{}' -> '{}' is NOT NoOp, handle = {}\n",
            //                inputColorSpace, outputColorSpace, (bool)handle);
        }
    }

    if (!handle && p) {
        // If we found a processor from OCIO, even if it was a NoOp, and we
        // still don't have a better idea, return it.
        handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
    }

    if (pending_error.size())
        getImpl()->error("{}", pending_error);

    return getImpl()->addproc(prockey, handle);
}



ColorProcessorHandle
ColorConfig::createLookTransform(string_view looks, string_view inputColorSpace,
                                 string_view outputColorSpace, bool inverse,
                                 string_view context_key,
                                 string_view context_value) const
{
    return createLookTransform(ustring(looks), ustring(inputColorSpace),
                               ustring(outputColorSpace), inverse,
                               ustring(context_key), ustring(context_value));
}



ColorProcessorHandle
ColorConfig::createLookTransform(ustring looks, ustring inputColorSpace,
                                 ustring outputColorSpace, bool inverse,
                                 ustring context_key,
                                 ustring context_value) const
{
    // First, look up the requested processor in the cache. If it already
    // exists, just return it.
    ColorProcCacheKey prockey(inputColorSpace, outputColorSpace, context_key,
                              context_value, looks, ustring() /*display*/,
                              ustring() /*view*/, ustring() /*file*/,
                              ustring() /*namedtransform*/, inverse);
    ColorProcessorHandle handle = getImpl()->findproc(prockey);
    if (handle)
        return handle;

    // Ask OCIO to make a Processor that can handle the requested
    // transformation.

    // TODO: Handle the case where either inputColorSpace or outputColorSpace
    // is a builtin interop identity, similar to createColorProcessor.
    if (getImpl()->config_ && !disable_ocio) {
        OCIO::ConstConfigRcPtr config      = getImpl()->config_;
        OCIO::LookTransformRcPtr transform = OCIO::LookTransform::Create();
        transform->setLooks(looks.c_str());
        OCIO::TransformDirection dir;
        if (inverse) {
            // The TRANSFORM_DIR_INVERSE applies an inverse for the
            // end-to-end transform, which would otherwise do dst->inv
            // look -> src.  This is an unintuitive result for the
            // artist (who would expect in, out to remain unchanged), so
            // we account for that here by flipping src/dst
            transform->setSrc(c_str(resolve(outputColorSpace)));
            transform->setDst(c_str(resolve(inputColorSpace)));
            dir = OCIO::TRANSFORM_DIR_INVERSE;
        } else {  // forward
            transform->setSrc(c_str(resolve(inputColorSpace)));
            transform->setDst(c_str(resolve(outputColorSpace)));
            dir = OCIO::TRANSFORM_DIR_FORWARD;
        }
        auto context = config->getCurrentContext();
        auto keys    = Strutil::splits(context_key, ",");
        auto values  = Strutil::splits(context_value, ",");
        if (keys.size() && values.size() && keys.size() == values.size()) {
            OCIO::ContextRcPtr ctx = context->createEditableCopy();
            for (size_t i = 0; i < keys.size(); ++i)
                ctx->setStringVar(keys[i].c_str(), values[i].c_str());
            context = ctx;
        }

        OCIO::ConstProcessorRcPtr p;
        try {
            // Get the processor corresponding to this transform.
            p = getImpl()->config_->getProcessor(context, transform, dir);
            getImpl()->clear_error();
            handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
        } catch (OCIO::Exception& e) {
            getImpl()->error(e.what());
        } catch (...) {
            getImpl()->error(
                "An unknown error occurred in OpenColorIO, getProcessor");
        }
    }

    return getImpl()->addproc(prockey, handle);
}



ColorProcessorHandle
ColorConfig::createDisplayTransform(string_view display, string_view view,
                                    string_view inputColorSpace,
                                    string_view looks, bool inverse,
                                    string_view context_key,
                                    string_view context_value) const
{
    return createDisplayTransform(ustring(display), ustring(view),
                                  ustring(inputColorSpace), ustring(looks),
                                  inverse, ustring(context_key),
                                  ustring(context_value));
}



ColorProcessorHandle
ColorConfig::createDisplayTransform(ustring display, ustring view,
                                    ustring inputColorSpace, ustring looks,
                                    bool inverse, ustring context_key,
                                    ustring context_value) const
{
    // First, look up the requested processor in the cache. If it already
    // exists, just return it.
    ColorProcCacheKey prockey(inputColorSpace, ustring() /*outputColorSpace*/,
                              context_key, context_value, looks, display, view,
                              ustring() /*file*/, ustring() /*namedtransform*/,
                              inverse);
    ColorProcessorHandle handle = getImpl()->findproc(prockey);
    if (handle)
        return handle;

    // Ask OCIO to make a Processor that can handle the requested
    // transformation.

    auto xf                       = OCIO::GroupTransform::Create();
    auto interop_csc              = OCIO::GroupTransform::Create();
    OCIO::ConstConfigRcPtr config = getImpl()->config_;
    OCIO::TransformDirection dir  = inverse ? OCIO::TRANSFORM_DIR_INVERSE
                                            : OCIO::TRANSFORM_DIR_FORWARD;
    auto context                  = config->getCurrentContext();
    auto keys                     = Strutil::splits(context_key, ",");
    auto values                   = Strutil::splits(context_value, ",");
    if (keys.size() && values.size() && keys.size() == values.size()) {
        OCIO::ContextRcPtr ctx = context->createEditableCopy();
        for (size_t i = 0; i < keys.size(); ++i)
            ctx->setStringVar(keys[i].c_str(), values[i].c_str());
        context = ctx;
    }

    OCIO::DisplayViewTransformRcPtr dvt = OCIO::DisplayViewTransform::Create();
    dvt->setDisplay(display.c_str());
    dvt->setView(view.c_str());
    dvt->setDirection(dir);

    // The IBA that calls this function should have ensured that
    // `inputColorSpace` is either a color space name, alias, or role
    // in the current config, or it's a color space found in the builtin
    // interop identities config, or it's found in the default_config.

    if (config->getCanonicalName(c_str(inputColorSpace))) {
        // If the inputColorSpace is found in the current config, great.
        dvt->setSrc(c_str(inputColorSpace));
        // TODO: if `looks` is empty, we can create a processor right now
        // and cut out early.
    } else {
        // Otherwise, it must be a color space from the interop config or
        // the default config. In either case, we need to do a cross-config
        // color space conversion.

        // TODO: check to see if the color space exists in the default config.
        // If not, check to see if it exists in the interop config.
        // If not, log an error and return an empty processor.
        // (ideally, the IBA would have already ensured that the inputColorSpace
        // is valid in either the interop config, the current config, or the
        // default config, if those last two aren't the same thing.)
        //
        // For now, assume that if the inputColorSpace is not found in the
        // current config, it must exist in the interop config.

        // We'll be using the current config's scene_linear color space
        // as a bridge to connect the interop config to the current
        // config in two steps:
        //
        // Step 1: Cross-config color space conversion:
        //   interop_config:inputColorSpace --> current_config:scene_linear
        // Step 2: Display view transform:
        //   scene_linear --> display/view
        //
        // Note: there's a more straightforward way to do this in one step
        // with GetProcessorFromConfigs, but we'd lose the ability to
        // override the looks with a custom string. See the use of
        // LegacyViewingPipeline below for more details.

        try {
            getImpl()->clear_error();
            auto interop_config  = getImpl()->interopconfig_;
            auto interop_context = interop_config->getCurrentContext();
            interop_csc          = OCIO::Config::GetProcessorFromConfigs(
                              interop_context, interop_config,
                              c_str(inputColorSpace), context, config,
                              c_str(OCIO::ROLE_SCENE_LINEAR))
                              ->createGroupTransform();

        } catch (OCIO::Exception& e) {
            getImpl()->error(e.what());
        } catch (...) {
            getImpl()->error(
                "An unknown error occurred converting from color space '{}'.",
                inputColorSpace);
        }

        // Set the DisplayViewTransform src to the scene_linear role (step 2).
        dvt->setSrc(OCIO::ROLE_SCENE_LINEAR);
    }

    try {
        if (looks.size()) {
            // We wrap the DisplayViewTransform in a LegacyViewingPipeline here
            // because it exposes a simple way to override the looks used with
            // a custom string.
            auto lvp = OCIO::LegacyViewingPipeline::Create();
            lvp->setDisplayViewTransform(dvt);
            lvp->setLooksOverride(looks.c_str());
            lvp->setLooksOverrideEnabled(true);
            xf = lvp->getProcessor(config, context)->createGroupTransform();
        } else
            // If no looks were specified, we can skip the extra layer of
            // the LegacyViewingPipeline and just get the GroupTransform
            // directly from the DisplayViewTransform.
            xf = config->getProcessor(context, dvt, OCIO::TRANSFORM_DIR_FORWARD)
                     ->createGroupTransform();
    } catch (OCIO::Exception& e) {
        getImpl()->error(e.what());
    } catch (...) {
        getImpl()->error(
            "An unknown error occurred creating DisplayViewTransform: "
            "{} -> {}/{} (looks='{}')",
            inputColorSpace, display, view, looks);
    }

    if (interop_csc->getNumTransforms() > 0) {
        // If we have a valid interop color space conversion,
        // we need to attach it to the DisplayViewTransform.
        if (inverse) {
            // If we're inverting the overall transform, invert
            // the interop_csc as well, and apply _after_ the main
            // DisplayViewTransform, instead of before.
            interop_csc->setDirection(OCIO::TRANSFORM_DIR_INVERSE);
            xf->appendTransform(interop_csc);
        } else {
            // Otherwise, just apply the interop color space conversion
            // before the main DisplayViewTransform.
            xf->prependTransform(interop_csc);
        }
    }
    // By this point, we've validated and hardened all the transforms
    // we're using, so we can safely ask OCIO to kindl create a
    // processor for us that wraps this whole thing up.
    OCIO::ConstProcessorRcPtr p = config->getProcessor(xf);
    handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
    return getImpl()->addproc(prockey, handle);
}



ColorProcessorHandle
ColorConfig::createFileTransform(string_view name, bool inverse) const
{
    return createFileTransform(ustring(name), inverse);
}



ColorProcessorHandle
ColorConfig::createFileTransform(ustring name, bool inverse) const
{
    // First, look up the requested processor in the cache. If it already
    // exists, just return it.
    ColorProcCacheKey prockey(ustring() /*inputColorSpace*/,
                              ustring() /*outputColorSpace*/,
                              ustring() /*context_key*/,
                              ustring() /*context_value*/, ustring() /*looks*/,
                              ustring() /*display*/, ustring() /*view*/,
                              ustring() /*file*/, name, inverse);
    ColorProcessorHandle handle = getImpl()->findproc(prockey);
    if (handle)
        return handle;

    // Ask OCIO to make a Processor that can handle the requested
    // transformation.
    OCIO::ConstConfigRcPtr config = getImpl()->config_;
    // If no config was found, config_ will be null. But that shouldn't
    // stop us for a filetransform, which doesn't need color spaces anyway.
    // Just use the default current config, it'll be freed when we exit.
    if (!config)
        config = ocio_current_config;
    if (config) {
        OCIO::FileTransformRcPtr transform = OCIO::FileTransform::Create();
        transform->setSrc(name.c_str());
        transform->setInterpolation(OCIO::INTERP_BEST);
        OCIO::TransformDirection dir    = inverse ? OCIO::TRANSFORM_DIR_INVERSE
                                                  : OCIO::TRANSFORM_DIR_FORWARD;
        OCIO::ConstContextRcPtr context = config->getCurrentContext();
        OCIO::ConstProcessorRcPtr p;
        try {
            // Get the processor corresponding to this transform.
            p = config->getProcessor(context, transform, dir);
            getImpl()->clear_error();
            handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
        } catch (OCIO::Exception& e) {
            getImpl()->error(e.what());
        } catch (...) {
            getImpl()->error(
                "An unknown error occurred in OpenColorIO, getProcessor");
        }
    }

    return getImpl()->addproc(prockey, handle);
}



ColorProcessorHandle
ColorConfig::createNamedTransform(string_view name, bool inverse,
                                  string_view context_key,
                                  string_view context_value) const
{
    return createNamedTransform(ustring(name), inverse, ustring(context_key),
                                ustring(context_value));
}



ColorProcessorHandle
ColorConfig::createNamedTransform(ustring name, bool inverse,
                                  ustring context_key,
                                  ustring context_value) const
{
    // First, look up the requested processor in the cache. If it already
    // exists, just return it.
    ColorProcCacheKey prockey(ustring() /*inputColorSpace*/,
                              ustring() /*outputColorSpace*/, context_key,
                              context_value, ustring() /*looks*/,
                              ustring() /*display*/, ustring() /*view*/,
                              ustring() /*file*/, name, inverse);
    ColorProcessorHandle handle = getImpl()->findproc(prockey);
    if (handle)
        return handle;

    // Ask OCIO to make a Processor that can handle the requested
    // transformation.
    if (getImpl()->config_ && !disable_ocio) {
        OCIO::ConstConfigRcPtr config = getImpl()->config_;
        auto transform                = config->getNamedTransform(name.c_str());
        OCIO::TransformDirection dir  = inverse ? OCIO::TRANSFORM_DIR_INVERSE
                                                : OCIO::TRANSFORM_DIR_FORWARD;
        auto context                  = config->getCurrentContext();
        auto keys                     = Strutil::splits(context_key, ",");
        auto values                   = Strutil::splits(context_value, ",");
        if (keys.size() && values.size() && keys.size() == values.size()) {
            OCIO::ContextRcPtr ctx = context->createEditableCopy();
            for (size_t i = 0; i < keys.size(); ++i)
                ctx->setStringVar(keys[i].c_str(), values[i].c_str());
            context = ctx;
        }

        OCIO::ConstProcessorRcPtr p;
        try {
            // Get the processor corresponding to this transform.
            p = config->getProcessor(context, transform, dir);
            getImpl()->clear_error();
            handle = ColorProcessorHandle(new ColorProcessor_OCIO(p));
        } catch (OCIO::Exception& e) {
            getImpl()->error(e.what());
        } catch (...) {
            getImpl()->error(
                "An unknown error occurred in OpenColorIO, getProcessor");
        }
    }

    return getImpl()->addproc(prockey, handle);
}



ColorProcessorHandle
ColorConfig::createMatrixTransform(M44fParam M, bool inverse) const
{
    return ColorProcessorHandle(
        new ColorProcessor_Matrix(*(const Imath::M44f*)M.data(), inverse));
}



string_view
ColorConfig::getColorSpaceFromFilepath(string_view str) const
{
    if (getImpl() && getImpl()->config_) {
        std::string s(str);
        string_view r = getImpl()->config_->getColorSpaceFromFilepath(
            s.c_str());
        return r;
    }
    // Fall back on parseColorSpaceFromString
    return parseColorSpaceFromString(str);
}

string_view
ColorConfig::getColorSpaceFromFilepath(string_view str, string_view default_cs,
                                       bool cs_name_match) const
{
    if (getImpl() && getImpl()->config_) {
        std::string s(str);
        string_view r = getImpl()->config_->getColorSpaceFromFilepath(
            s.c_str());
        if (!getImpl()->config_->filepathOnlyMatchesDefaultRule(s.c_str()))
            return r;
    }
    if (cs_name_match) {
        string_view parsed = parseColorSpaceFromString(str);
        if (parsed.size())
            return parsed;
    }
    return default_cs;
}

bool
ColorConfig::filepathOnlyMatchesDefaultRule(string_view str) const
{
    return getImpl()->config_->filepathOnlyMatchesDefaultRule(c_str(str));
}

string_view
ColorConfig::parseColorSpaceFromString(string_view str) const
{
    // Reproduce the logic in OCIO v1 parseColorSpaceFromString

    if (str.empty())
        return "";

    // Get the colorspace names, sorted shortest-to-longest
    auto names = getColorSpaceNames();
    std::sort(names.begin(), names.end(),
              [](const std::string& a, const std::string& b) {
                  return a.length() < b.length();
              });

    // See if it matches a LUT name.
    // This is the position of the RIGHT end of the colorspace substring,
    // not the left
    size_t rightMostColorPos = std::string::npos;
    std::string rightMostColorspace;

    // Find the right-most occurrence within the string for each colorspace.
    for (auto&& csname : names) {
        // find right-most extension matched in filename
        size_t pos = Strutil::irfind(str, csname);
        if (pos == std::string::npos)
            continue;

        // If we have found a match, move the pointer over to the right end
        // of the substring.  This will allow us to find the longest name
        // that matches the rightmost colorspace
        pos += csname.size();

        if (rightMostColorPos == std::string::npos
            || pos >= rightMostColorPos) {
            rightMostColorPos   = pos;
            rightMostColorspace = csname;
        }
    }
    return string_view(ustring(rightMostColorspace));
}


//////////////////////////////////////////////////////////////////////////
//
// Color Interop ID

namespace {
enum class CICPPrimaries : int {
    Rec709      = 1,
    Unspecified = 2,
    Rec2020     = 9,
    XYZD65      = 10,
    P3D65       = 12,
};

enum class CICPTransfer : int {
    BT709       = 1,
    Unspecified = 2,
    Gamma22     = 4,
    Linear      = 8,
    sRGB        = 13,
    PQ          = 16,
    Gamma26     = 17,
    HLG         = 18,
};

enum class CICPMatrix : int {
    RGB         = 0,
    BT709       = 1,
    Unspecified = 2,
    Rec2020_NCL = 9,
    Rec2020_CL  = 10,
};

enum class CICPRange : int {
    Narrow = 0,
    Full   = 1,
};

struct ColorInteropID {
    constexpr ColorInteropID(const char* interop_id)
        : interop_id(interop_id)
        , cicp({ 0, 0, 0, 0 })
        , has_cicp(false)
    {
    }

    constexpr ColorInteropID(const char* interop_id, CICPPrimaries primaries,
                             CICPTransfer transfer, CICPMatrix matrix)
        : interop_id(interop_id)
        , cicp({ int(primaries), int(transfer), int(matrix),
                 int(CICPRange::Full) })
        , has_cicp(true)
    {
    }

    const char* interop_id;
    std::array<int, 4> cicp;
    bool has_cicp;
};

// Mapping between color interop ID and CICP, based on Color Interop Forum
// recommendations.
constexpr ColorInteropID color_interop_ids[] = {
    // Display referred interop IDs first so they are the default in automatic
    // conversion from CICP to interop ID.
    { "srgb_rec709_display", CICPPrimaries::Rec709, CICPTransfer::sRGB,
      CICPMatrix::BT709 },
    { "g24_rec709_display", CICPPrimaries::Rec709, CICPTransfer::BT709,
      CICPMatrix::BT709 },
    { "srgb_p3d65_display", CICPPrimaries::P3D65, CICPTransfer::sRGB,
      CICPMatrix::BT709 },
    { "srgbe_p3d65_display", CICPPrimaries::P3D65, CICPTransfer::sRGB,
      CICPMatrix::BT709 },
    { "pq_p3d65_display", CICPPrimaries::P3D65, CICPTransfer::PQ,
      CICPMatrix::Rec2020_NCL },
    { "pq_rec2020_display", CICPPrimaries::Rec2020, CICPTransfer::PQ,
      CICPMatrix::Rec2020_NCL },
    { "hlg_rec2020_display", CICPPrimaries::Rec2020, CICPTransfer::HLG,
      CICPMatrix::Rec2020_NCL },
    { "g22_rec709_display", CICPPrimaries::Rec709, CICPTransfer::Gamma22,
      CICPMatrix::BT709 },
    // No CICP code for Adobe RGB primaries.
    { "g22_adobergb_display" },
    { "g26_p3d65_display", CICPPrimaries::P3D65, CICPTransfer::Gamma26,
      CICPMatrix::BT709 },
    { "g26_xyzd65_display", CICPPrimaries::XYZD65, CICPTransfer::Gamma26,
      CICPMatrix::Unspecified },
    { "pq_xyzd65_display", CICPPrimaries::XYZD65, CICPTransfer::PQ,
      CICPMatrix::Unspecified },

    // Some scene referred interop IDs can be represented by CICP
    { "lin_ap1_scene" },
    { "lin_ap0_scene" },
    { "lin_rec709_scene", CICPPrimaries::Rec709, CICPTransfer::Linear,
      CICPMatrix::BT709 },
    { "lin_p3d65_scene", CICPPrimaries::P3D65, CICPTransfer::Linear,
      CICPMatrix::BT709 },
    { "lin_rec2020_scene", CICPPrimaries::Rec2020, CICPTransfer::Linear,
      CICPMatrix::Rec2020_CL },
    { "lin_adobergb_scene" },
    { "lin_ciexyzd65_scene", CICPPrimaries::XYZD65, CICPTransfer::Linear,
      CICPMatrix::Unspecified },
    { "srgb_rec709_scene", CICPPrimaries::Rec709, CICPTransfer::sRGB,
      CICPMatrix::BT709 },
    { "g22_rec709_scene", CICPPrimaries::Rec709, CICPTransfer::Gamma22,
      CICPMatrix::BT709 },
    { "g18_rec709_scene" },
    { "srgb_ap1_scene" },
    { "g22_ap1_scene" },
    { "srgb_p3d65_scene", CICPPrimaries::P3D65, CICPTransfer::sRGB,
      CICPMatrix::BT709 },
    { "g22_adobergb_scene" },

    // Other standard CIF interop IDs
    { "data" },
    { "unknown", CICPPrimaries::Unspecified, CICPTransfer::Unspecified,
      CICPMatrix::Unspecified },
};
}  // namespace

string_view
ColorConfig::get_color_interop_id(string_view colorspace, bool strict) const
{
    // Equality IDs vs interop IDs:
    // - equality_id: a derived interop_id value that reflects the *actual*
    //   transform graph for a colorspace in a given context (i.e., what it
    //   really does).
    // - interop_id: an author-declared value intended for downstream metadata
    //   (EXR colorInteropID, PNG cICP/gAMA/cHRM, etc.); may not match the
    //   actual transforms.
    //
    // Examples:
    // 1) A LUT-based colorspace is not "identifiable" by transforms, but if
    //    it declares interop_id="g24_rec709_display", we use the built-in
    //    Rec.709 display identity for metadata/chromaticities.
    // 2) A context-driven colorspace may yield different equality_ids across
    //    contexts, while the author may choose a constant interop_id.
    if (colorspace.empty())
        return colorspace;

    auto config        = getImpl()->config_;
    auto interopconfig = getImpl()->interopconfig_;
    auto cs = config ? config->getColorSpace(c_str(colorspace)) : nullptr;
    if (!cs && config) {
        // Resolve roles/aliases to a canonical color space name.
        string_view resolved = resolve(colorspace);
        if (!resolved.empty())
            cs = config->getColorSpace(c_str(resolved));
    }

#if OCIO_VERSION_HEX >= MAKE_OCIO_VERSION_HEX(2, 5, 0)
    if (cs) {
        string_view interop_id = cs->getInteropID();
        if (!interop_id.empty())
            return interop_id;
    }
#endif
    if (strict)
        return "";

    // Check to see if this colorspace's name or any of its aliases match
    // a known interop ID in the interop config.
    if (interopconfig) {
        if (cs) {
            auto interop_cs = interopconfig->getColorSpace(cs->getName());
            if (interop_cs)
                return interop_cs->getName();
            for (size_t i = 0, e = cs->getNumAliases(); i < e; ++i) {
                string_view alias = cs->getAlias(static_cast<int>(i));
                interop_cs        = interopconfig->getColorSpace(c_str(alias));
                if (interop_cs)
                    return interop_cs->getName();
            }
        }

        auto interop_cs = interopconfig->getColorSpace(c_str(colorspace));
        if (interop_cs)
            return interop_cs->getName();
    }

    // Finally, see if we can match by definitionally equivalent built-ins.
    if (cs) {
        string_view cached = getImpl()->get_cached_equality_id(cs->getName());
        if (!cached.empty())
            return cached;
    }

    return "";
}

string_view
ColorConfig::get_color_interop_id(const int cicp[4]) const
{
    for (const ColorInteropID& interop : color_interop_ids) {
        if (interop.has_cicp && interop.cicp[0] == cicp[0]
            && interop.cicp[1] == cicp[1]) {
            return interop.interop_id;
        }
    }
    return "";
}

std::map<std::string, std::string>
ColorConfig::get_equality_ids() const
{
    return getImpl()->get_equality_ids();
}

std::map<std::string, std::string>
ColorConfig::get_equality_ids(
    bool exhaustive, const std::map<std::string, std::string>& context) const
{
    return getImpl()->get_equality_ids(exhaustive, context);
}

std::map<std::string, std::string>
ColorConfig::get_interop_ids(
    bool strict, bool exhaustive,
    const std::map<std::string, std::string>& context) const
{
    return getImpl()->get_interop_ids(strict, exhaustive, context);
}

std::vector<float>
ColorConfig::get_colorspace_fingerprint(
    string_view colorspace,
    const std::map<std::string, std::string>& context) const
{
    return getImpl()->get_colorspace_fingerprint(colorspace, context);
}

std::string
ColorConfig::find_colorspace_from_fingerprint(
    const std::vector<float>& fingerprint, bool display_referred,
    const std::map<std::string, std::string>& context) const
{
    return getImpl()->find_colorspace_from_fingerprint(fingerprint,
                                                       display_referred,
                                                       context);
}

std::vector<std::pair<std::string, std::string>>
ColorConfig::get_intersection(
    const ColorConfig& other,
    const std::map<std::string, std::string>& base_context,
    const std::map<std::string, std::string>& other_context) const
{
    return getImpl()->get_intersection(other, base_context, other_context);
}
std::string
ColorConfig::get_color_interop_id(
    string_view colorspace, bool strict,
    const std::map<std::string, std::string>& context) const
{
    return getImpl()->get_color_interop_id(colorspace, strict, context);
}

cspan<int>
ColorConfig::get_cicp(string_view colorspace) const
{
    string_view interop_id = get_color_interop_id(colorspace);
    if (!interop_id.empty()) {
        for (const ColorInteropID& interop : color_interop_ids) {
            if (interop.has_cicp && interop_id == interop.interop_id) {
                return interop.cicp;
            }
        }
    }
    return cspan<int>();
}



//////////////////////////////////////////////////////////////////////////////////
//
// ConfigUtils -- Helpers for working with OCIO Configs, taken from the OCIO
// library itself. Necessary since these functions are not part of the public API.
//
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026

namespace ConfigUtils {

using namespace OCIO;
// NOTE: The helpers below are adapted from OCIO's internal utilities.
// We keep them here to avoid depending on private OCIO headers while still
// matching OCIO's config manipulation behavior.


// Invert a transform by toggling its direction.
ConstTransformRcPtr
invertTransform(const ConstTransformRcPtr& t);
// Fetch a colorspace transform for a direction, or invert the opposite.
ConstTransformRcPtr
getTransformDir(const ConstColorSpaceRcPtr& cs, ColorSpaceDirection dir);

// Build a transform that converts between reference spaces of two configs.
ConstTransformRcPtr
getRefSpaceConverter(const ConstConfigRcPtr& srcConfig,
                     const ConstConfigRcPtr& dstConfig,
                     ReferenceSpaceType refSpaceType);

// Precompute converters from an input config to a base config for both
// scene- and display-referred spaces.
void
initializeRefSpaceConverters(ConstTransformRcPtr& inputToBaseGtScene,
                             ConstTransformRcPtr& inputToBaseGtDisplay,
                             const ConstConfigRcPtr& baseConfig,
                             const ConstConfigRcPtr& inputConfig);

// Rewrite a colorspace's transforms to a new reference space.
void
updateReferenceColorspace(ColorSpaceRcPtr& cs,
                          const ConstTransformRcPtr& toNewReferenceTransform);
// Rewrite a view transform to new scene/display reference spaces.
void
updateReferenceView(ViewTransformRcPtr& vt,
                    const ConstTransformRcPtr& toNewSceneReferenceTransform,
                    const ConstTransformRcPtr& toNewDisplayReferenceTransform);

// Return a copy of config whose reference spaces are adapted to otherConfig.
ConfigRcPtr
adaptConfigReferenceSpaces(const ConstConfigRcPtr& config,
                           const ConstConfigRcPtr& otherConfig);

// Compute a fingerprint for a colorspace, optionally skipping complex transforms.
bool
calcColorSpaceFingerprint(std::vector<float>& fingerprintVals,
                          const ColorSpaceFingerprints& fingerprints,
                          const ConstConfigRcPtr& config,
                          const ConstColorSpaceRcPtr& cs,
                          const ConstContextRcPtr& context);

// Populate the fingerprints container and name lookup for a config.
void
initializeColorSpaceFingerprints(
    ColorSpaceFingerprints& fingerprints,
    std::unordered_map<std::string, Fingerprint>& by_name,
    const ConstConfigRcPtr& config, const ConstContextRcPtr& context);

// Get (or create) a cache entry for the config+context key.
FingerprintCacheEntry
get_fingerprint_cache_entry(const ConstConfigRcPtr& config,
                            const ConstContextRcPtr& context,
                            FingerprintCacheMap& cache,
                            std::mutex& cache_mutex);

// Try to fetch a cached fingerprint for a colorspace.
bool
get_cached_fingerprint_for_colorspace(const ConstConfigRcPtr& config,
                                      const ConstColorSpaceRcPtr& cs,
                                      const ConstContextRcPtr& context,
                                      ColorSpaceFingerprints& fingerprints,
                                      std::vector<float>& fingerprintVals,
                                      FingerprintCacheMap& cache,
                                      std::mutex& cache_mutex);

// Compute (and cache) a fingerprint for a colorspace name.
std::vector<float>
get_colorspace_fingerprint(const ConstConfigRcPtr& config,
                           string_view colorspace,
                           const ConstContextRcPtr& context,
                           FingerprintCacheMap& cache, std::mutex& cache_mutex);

// Find a colorspace whose fingerprint matches the given values.
std::string
find_colorspace_from_fingerprint(const ConstConfigRcPtr& config,
                                 cspan<const float> fingerprint,
                                 ReferenceSpaceType refSpaceType,
                                 const ConstContextRcPtr& context,
                                 FingerprintCacheMap& cache,
                                 std::mutex& cache_mutex);

// Fast matcher that compares fingerprints to the built-in interop identities.
class FastColorSpaceMatcher {
public:
    FastColorSpaceMatcher(const ConstConfigRcPtr& baseConfig,
                          FingerprintCacheMap& cache, std::mutex& cache_mutex);

    std::string findEquivalentColorspace(const ConstConfigRcPtr& inputConfig,
                                         string_view csName,
                                         const ConstContextRcPtr& context) const;

private:
    std::string findEquivalentColorspaceFromFingerprint(
        const std::vector<float>& inputVals,
        ReferenceSpaceType refSpaceType) const;

    ColorSpaceFingerprints m_base_fingerprints;
    std::string m_baseConfigName;
    FingerprintCacheMap* m_cache = nullptr;
    std::mutex* m_cache_mutex    = nullptr;
};

std::string
findEquivalentColorspace(const ColorSpaceFingerprints& fingerprints,
                         const ConstConfigRcPtr& inputConfig,
                         const ConstColorSpaceRcPtr& inputCS);

std::vector<std::string>
get_simple_color_spaces(const ConstConfigRcPtr& config);
std::map<std::string, std::string>
get_simple_color_space_blockers(const ConstConfigRcPtr& config);

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Temporarily deactivate the Processor cache on a Config object.
//
class SuspendCacheGuard {
public:
    SuspendCacheGuard();
    SuspendCacheGuard(const SuspendCacheGuard&)            = delete;
    SuspendCacheGuard& operator=(const SuspendCacheGuard&) = delete;

    SuspendCacheGuard(const ConstConfigRcPtr& config)
        : m_config(config)
        , m_origCacheFlags(config->getProcessorCacheFlags())
    {
        m_config->setProcessorCacheFlags(PROCESSOR_CACHE_OFF);
    }

    ~SuspendCacheGuard() { m_config->setProcessorCacheFlags(m_origCacheFlags); }

private:
    ConstConfigRcPtr m_config = nullptr;
    ProcessorCacheFlags m_origCacheFlags;
};

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Simplify a transform by removing nested group transforms and identities.
//
ConstTransformRcPtr
simplifyTransform(const ConstGroupTransformRcPtr& gt)
{
    ConstConfigRcPtr config = Config::CreateRaw();
    ConstProcessorRcPtr p   = config->getProcessor(gt);
    ConstProcessorRcPtr opt = p->getOptimizedProcessor(OPTIMIZATION_DEFAULT);
    GroupTransformRcPtr finalGt = opt->createGroupTransform();
    if (finalGt->getNumTransforms() == 1) {
        return finalGt->getTransform(0);
    }
    return finalGt;
}

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
ConstTransformRcPtr
invertTransform(const ConstTransformRcPtr& t)
{
    TransformRcPtr eT = t->createEditableCopy();
    eT->setDirection(TRANSFORM_DIR_INVERSE);
    return eT;
}

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Return a transform in either the to_ref or from_ref direction for this color space.
// Return an identity matrix, if the color space has no transforms.
//
ConstTransformRcPtr
getTransformForDir(const ConstColorSpaceRcPtr& cs, ColorSpaceDirection dir)
{
    ColorSpaceDirection otherDir = COLORSPACE_DIR_TO_REFERENCE;
    if (dir == COLORSPACE_DIR_TO_REFERENCE) {
        otherDir = COLORSPACE_DIR_FROM_REFERENCE;
    }

    ConstTransformRcPtr t = cs->getTransform(dir);
    if (t) {
        return t;
    }

    ConstTransformRcPtr tOther = cs->getTransform(otherDir);
    if (tOther) {
        return invertTransform(tOther);
    }

    // If it's the reference space, it won't have a transform, so return an identity matrix.
    double m44[16];
    double offset4[4];
    MatrixTransform::Identity(m44, offset4);
    MatrixTransformRcPtr p = MatrixTransform::Create();
    p->setMatrix(m44);
    p->setOffset(offset4);

    return p;
}


// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Get a transform to convert from the source config reference space to the
// destination config reference space.  The ref_space_type specifies whether
// to work with the scene-referred or display-referred reference space.
ConstTransformRcPtr getRefSpaceConverter(const ConstConfigRcPtr & srcConfig, 
                                         const ConstConfigRcPtr & dstConfig, 
                                         ReferenceSpaceType refSpaceType)
{
    ConstConfigRcPtr builtinConfig = Config::CreateFromBuiltinConfig("ocio://cg-config-latest");

    auto getColorspaceOfRefType = [](const ConstConfigRcPtr & config, 
                                     ReferenceSpaceType refType) -> const char *
    {
        // Just return the first one, doesn't matter if it's inactive or a data space.
        // All that matters is the reference space type.
        // Casting to SearchReferenceSpaceType since they have the same values.
        SearchReferenceSpaceType searchRefType = static_cast<SearchReferenceSpaceType>(refType);
        for (int i = 0; i < config->getNumColorSpaces(searchRefType, COLORSPACE_ALL); i++)
        {
            const char * name = config->getColorSpaceNameByIndex(searchRefType, COLORSPACE_ALL, i);
            ConstColorSpaceRcPtr cs = config->getColorSpace(name);
            return cs->getName();
        }

        throw Exception("Config is lacking any color spaces of the requested reference space type.");
    };

    // Identify an interchange space for the src config.
    // Note that the interchange space will always be a linear color space.
    // TODO: IdentifyInterchangeSpace currently fails if the config does not have
    //  a color space for the reference space.
    // TODO: IdentifyInterchangeSpace will fail in the display-referred case if the
    //  config does not have the cie_xyz_d65_interchange role.
    const char * srcInterchange = nullptr;
    const char * srcBuiltinInterchange = nullptr;
    Config::IdentifyInterchangeSpace(&srcInterchange,
                                     &srcBuiltinInterchange,
                                     srcConfig,
                                     getColorspaceOfRefType(srcConfig, refSpaceType),
                                     builtinConfig,
                                     getColorspaceOfRefType(builtinConfig, refSpaceType));

    // Identify an interchange space for the dst config.
    // Note that the interchange space will always be a linear color space.
    const char * dstInterchange = nullptr;
    const char * dstBuiltinInterchange = nullptr;
    Config::IdentifyInterchangeSpace(&dstInterchange,
                                     &dstBuiltinInterchange,
                                     dstConfig,
                                     getColorspaceOfRefType(dstConfig, refSpaceType),
                                     builtinConfig,
                                     getColorspaceOfRefType(builtinConfig, refSpaceType));

    // Get the from_ref transform from the srcInterchange space.
    ConstTransformRcPtr srcFromRef = getTransformForDir(srcConfig->getColorSpace(srcInterchange), 
                                                        COLORSPACE_DIR_FROM_REFERENCE);

    // Get a conversion from one builtin interchange to another
    ColorSpaceTransformRcPtr cst = ColorSpaceTransform::Create();
    GroupTransformRcPtr srcBuiltinToDstBuiltin;
    if (srcBuiltinInterchange && *srcBuiltinInterchange &&
        dstBuiltinInterchange && *dstBuiltinInterchange)
    {
        // srcBuiltinInterchange and dstBuiltinInterchange are not empty.
        cst->setSrc(srcBuiltinInterchange);
        cst->setDst(dstBuiltinInterchange);

        srcBuiltinToDstBuiltin = builtinConfig->getProcessor(cst)->createGroupTransform();
    }

    // Append to_ref transform from the dstInterchange space.
    ConstTransformRcPtr dstToRef = getTransformForDir(dstConfig->getColorSpace(dstInterchange), 
                                                      COLORSPACE_DIR_TO_REFERENCE);

    // Combine into a group transform.
    // Note: Some of these pieces may be identities but the whole thing needs to get
    // simplified/optimized after being combined with the existing transform anyway
    // since one of these pieces may be the inverse of a color space's existing transform.
    GroupTransformRcPtr gt = GroupTransform::Create();

    // If the src or dst contain FileTransforms, resolve them so there is no dependence
    // on the search_path of the original configs. This is necessary for simplifyTransform
    // below and would fail if the conversion involved a transform that may not appear
    // in a config, such as a LUT.
    gt->appendTransform(srcConfig->getProcessor(srcFromRef)->createGroupTransform());
    gt->appendTransform(srcBuiltinToDstBuiltin);
    gt->appendTransform(dstConfig->getProcessor(dstToRef)->createGroupTransform());

    return simplifyTransform(gt);
}
// clang-format on

bool
transformIsEmpty(const ConstTransformRcPtr& tr)
{
    if (tr->getTransformType() == TRANSFORM_TYPE_GROUP) {
        ConstGroupTransformRcPtr gt = DynamicPtrCast<const GroupTransform>(tr);
        if (gt->getNumTransforms() == 0) {
            return true;
        }
    }
    return false;
}


// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Update the reference space used by a color space's transforms.
// The argument is a group transform that converts from the current to the new ref. space.
//
void updateReferenceColorspace(ColorSpaceRcPtr & cs, 
                               const ConstTransformRcPtr & toNewReferenceTransform)
{
    if (!toNewReferenceTransform || !cs)
    {
        std::ostringstream os;
        os << "Could not update reference space, converter transform was not initialized.";
        throw Exception(os.str().c_str());
    }

    if (transformIsEmpty(toNewReferenceTransform))
    {
        return;
    }

    ConstTransformRcPtr transformTo = cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
    if (transformTo)
    {
        GroupTransformRcPtr gt = GroupTransform::Create();
        gt->appendTransform(transformTo->createEditableCopy());
        gt->appendTransform(toNewReferenceTransform->createEditableCopy());

        // NB: Don't want to call simplify_transforms on gt since it would do things like
        // expand built-in or file transforms. But as a result, there could be transforms that
        // appear more complex than necessary. In some cases there could be color spaces
        // with transforms present that would actually simplify into an identity.  In other
        // words there could be color spaces that are effectively the reference space that
        // have from_ref or to_ref transforms.
        cs->setTransform(gt, COLORSPACE_DIR_TO_REFERENCE);
    }

    ConstTransformRcPtr transformFrom = cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
    if (transformFrom)
    {
        ConstTransformRcPtr inv = invertTransform(toNewReferenceTransform);
        GroupTransformRcPtr gt = GroupTransform::Create();
        gt->appendTransform(inv->createEditableCopy());
        gt->appendTransform(transformFrom->createEditableCopy());
        cs->setTransform(gt, COLORSPACE_DIR_FROM_REFERENCE);
    }

    if (transformTo == nullptr && transformFrom == nullptr && !cs->isData())
    {
        GroupTransformRcPtr gt = GroupTransform::Create();
        gt->appendTransform(toNewReferenceTransform->createEditableCopy());
        cs->setTransform(gt, COLORSPACE_DIR_TO_REFERENCE);
    }
}
// clang-format on


// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Update the transforms in a view transform to adapt the reference spaces.
// Note that the from_ref transform converts from the scene-referred reference space to
// the display-referred reference space.
//
void updateReferenceView(ViewTransformRcPtr & vt, 
                         const ConstTransformRcPtr & toNewSceneReferenceTransform,
                         const ConstTransformRcPtr & toNewDisplayReferenceTransform)
{
    if (!toNewSceneReferenceTransform || !toNewDisplayReferenceTransform || !vt)
    {
        std::ostringstream os;
        os << "Could not update view transform reference spaces, converter transforms were not initialized.";
        throw Exception(os.str().c_str());
    }
    // TODO: Is any more error checking needed here for robustness?

    const bool emptySceneSide = transformIsEmpty(toNewSceneReferenceTransform);
    const bool emptyDisplaySide = transformIsEmpty(toNewDisplayReferenceTransform);

    if (emptySceneSide && emptyDisplaySide) return;

    ConstTransformRcPtr transformTo = vt->getTransform(VIEWTRANSFORM_DIR_TO_REFERENCE);
    if (transformTo)
    {
        GroupTransformRcPtr gt = GroupTransform::Create();
        if (!emptyDisplaySide)
        {
            ConstTransformRcPtr inv = invertTransform(toNewDisplayReferenceTransform);
            gt->appendTransform(inv->createEditableCopy());
        }

        gt->appendTransform(transformTo->createEditableCopy());

        if (vt->getReferenceSpaceType() == REFERENCE_SPACE_DISPLAY)
        {
            // Use the converter to display reference on both sides.
            if (!emptyDisplaySide)
            {
                gt->appendTransform(toNewDisplayReferenceTransform->createEditableCopy());
            }
        }
        else
        {
            if (!emptySceneSide)
            {
                gt->appendTransform(toNewSceneReferenceTransform->createEditableCopy());
            }
        }
        vt->setTransform(gt, VIEWTRANSFORM_DIR_TO_REFERENCE);
    }

    ConstTransformRcPtr transformFrom = vt->getTransform(VIEWTRANSFORM_DIR_FROM_REFERENCE);
    if (transformFrom)
    {
        GroupTransformRcPtr gt = GroupTransform::Create();

        if (vt->getReferenceSpaceType() == REFERENCE_SPACE_DISPLAY)
        {
            // Use the converter to display reference on both sides.
            if (!emptyDisplaySide)
            {
                ConstTransformRcPtr inv = invertTransform(toNewDisplayReferenceTransform);
                gt->appendTransform(inv->createEditableCopy());
            }
        }
        else
        {
            if (!emptySceneSide)
            {
                ConstTransformRcPtr inv = invertTransform(toNewSceneReferenceTransform); 
                gt->appendTransform(inv->createEditableCopy());
            }
        }

        gt->appendTransform(transformFrom->createEditableCopy());

        if (!emptyDisplaySide)
        {
            gt->appendTransform(toNewDisplayReferenceTransform->createEditableCopy());
        }
        vt->setTransform(gt, VIEWTRANSFORM_DIR_FROM_REFERENCE);
    }

    // Note that Config::addViewTransform prevents creating a view transform that 
    // has no transforms, so at least one direction will be present.
}
// clang-format on

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// clang-format off
bool hasColorSpaceRefType(const ConstConfigRcPtr & config, ReferenceSpaceType refType)
{
    SearchReferenceSpaceType searchRefType = static_cast<SearchReferenceSpaceType>(refType);
    int n = config->getNumColorSpaces(searchRefType, COLORSPACE_ALL);
    return n > 0;
}
// clang-format on


// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Initialize the transforms that will be added to color spaces and view transforms to
// convert the reference space from one config to another.
//
void initializeRefSpaceConverters(ConstTransformRcPtr & inputToBaseGtScene,
                                  ConstTransformRcPtr & inputToBaseGtDisplay,
                                  const ConstConfigRcPtr & baseConfig,
                                  const ConstConfigRcPtr & inputConfig)
{
    // Note: The base config reference space is always used, regardless of strategy.

    if (hasColorSpaceRefType(baseConfig, REFERENCE_SPACE_SCENE) &&
        hasColorSpaceRefType(inputConfig, REFERENCE_SPACE_SCENE))
    {
        inputToBaseGtScene = getRefSpaceConverter(
            inputConfig,
            baseConfig,
            REFERENCE_SPACE_SCENE
        );
    }
    else
    {
        // Always need to initialize both transforms, even if they're empty.
        inputToBaseGtScene = GroupTransform::Create();
    }

    // Only attempt to build the converter if the input config has this type of
    // reference space. Using the input config for this determination since it is
    // only input config color spaces whose reference space is converted.
    if (hasColorSpaceRefType(baseConfig, REFERENCE_SPACE_DISPLAY) &&
        hasColorSpaceRefType(inputConfig, REFERENCE_SPACE_DISPLAY))
    {
        inputToBaseGtDisplay = getRefSpaceConverter(
            inputConfig,
            baseConfig,
            REFERENCE_SPACE_DISPLAY
        );
    }
    else
    {
        // Always need to initialize both transforms, even if they're empty.
        inputToBaseGtDisplay = GroupTransform::Create();
    }
}
// clang-format on

// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Send the test vals through the color space and store the result in fingerprintVals.
// Returns true if the color space should not be considered.
//
bool calcColorSpaceFingerprint(std::vector<float> & fingerprintVals, 
                               const ColorSpaceFingerprints & fingerprints, 
                               const ConstConfigRcPtr & config, 
                               const ConstColorSpaceRcPtr & cs,
                               const ConstContextRcPtr & context)
{
    bool skipColorSpace = false;

    // TODO: Would it be helpful to compare to_refs to to_refs, rather than inverting?
    ConstTransformRcPtr fromRef = getTransformForDir(cs, COLORSPACE_DIR_FROM_REFERENCE);

    ConstCPUProcessorRcPtr cpu;
    try
    {
        ConstContextRcPtr ctx = context ? context : config->getCurrentContext();
        ConstProcessorRcPtr p = config->getProcessor(ctx, fromRef,
                                                     TRANSFORM_DIR_FORWARD);
        cpu = p->getOptimizedCPUProcessor(OPTIMIZATION_NONE);
    }
    catch (...) 
    { 
        // If the transform doesn't validate (singular matrix, etc.), don't consider it.
        return true;
    }

    // TODO: Should skip some transforms, e.g. those with a 3d-LUT.

    if (cs->getReferenceSpaceType() == REFERENCE_SPACE_DISPLAY)
    {
        fingerprintVals = fingerprints.displayRefTestVals;
    }
    else
    {
        fingerprintVals = fingerprints.sceneRefTestVals;
    }
    const size_t n = fingerprintVals.size();
    PackedImageDesc desc( &fingerprintVals[0], (long) n / 4, 1, CHANNEL_ORDERING_RGBA );

    cpu->apply(desc);

    return skipColorSpace;
}

// clang-format off
// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// Define a set of test values to use for a config and store them in the fingerprints struct.
// An attempt is made to convert them to the reference spaces of the config being used.
// There are separate values for scene-referred and display-referred color spaces.
//
void initializeTestVals(ColorSpaceFingerprints & fingerprints, const ConstConfigRcPtr & config)
{
    // Define a set of test values that are slightly inside the Rec.709 gamut
    // for the most common scene-referred and display-referred reference spaces.

    // TODO: Including negative values would exclude some matches that are probably
    // desirable, it's an open question how strict the matching should be.

    std::vector<float> ACESvals = { 
        0.408933127871f, 0.106169822808f, 0.027842572707f, 0.f, // lin_rec709 {0.9, 0.03, 0.01}
        0.374615373650f, 0.739417755017f, 0.118862613721f, 0.f, // lin_rec709 {0.06, 0.9, 0.02}
        0.171696591718f, 0.104272268468f, 0.786227391453f, 0.f, // lin_rec709 {0.01, 0.02, 0.9}
        0.f            , 0.f            , 0.f            , 0.5f,
        0.037018876439f, 0.030827687576f, 0.021641700645f, 0.f, // lin_rec709 {0.05, 0.03, 0.02}
        1.f            , 1.f            , 1.f            , 1.f };

    std::vector<float> XYZvals = { 
        // Adjusted to keep it inside both Rec.601 and Rec.601 PAL.
        0.383684057405f, 0.213552088801f, 0.030478901760f, 0.f, // lin_rec709 {0.9, 0.03, 0.01}
        0.350178969169f, 0.657853997550f, 0.127445793983f, 0.f, // lin_rec709 {0.06, 0.9, 0.02}
        0.173708304342f, 0.081402847459f, 0.858056140808f, 0.f, // lin_rec709 {0.01, 0.02, 0.9}
        0.f            , 0.f            , 0.f            , 0.5f,
        0.034956685913f, 0.033530856964f, 0.023553027375f, 0.f, // lin_rec709 {0.05, 0.03, 0.02}
        0.950455927052f, 1.f            , 1.089057750760f, 1.f };

    // Try to convert to the actual reference spaces of the config.

    fingerprints.sceneRefTestVals = ACESvals;
    fingerprints.displayRefTestVals = XYZvals;

    ConstContextRcPtr ctx = config->getCurrentContext();
    ConstProcessorRcPtr p;
    try
    {
        // First check if the config recognizes one of the common names.
        ConstColorSpaceRcPtr cs;
        cs = config->getColorSpace("aces_interchange");
        if (!cs)
        {
            cs = config->getColorSpace("ACES2065-1");
            if (!cs)
            {
                cs = config->getColorSpace("lin_ap0_scene");
                if (!cs)
                {
                    // Otherwise, see if it's present using a different name.
                    ConstConfigRcPtr builtinConfig = Config::CreateFromBuiltinConfig("ocio://cg-config-latest");
                    // This throws if it cannot find the requested space.
                    const char * cs_name = 
                        Config::IdentifyBuiltinColorSpace(config, builtinConfig, "aces_interchange");
                    cs = config->getColorSpace(cs_name);
                }
            }
        }

        ConstTransformRcPtr toRef = getTransformForDir(cs, COLORSPACE_DIR_TO_REFERENCE);
        p = config->getProcessor(ctx, toRef, TRANSFORM_DIR_FORWARD);

        const size_t n = ACESvals.size();
        std::vector<float> out(n, 0.f);

        PackedImageDesc descSrc( &ACESvals[0], (long) n / 4, 1, CHANNEL_ORDERING_RGBA );
        PackedImageDesc descDst( &out[0], (long) n / 4, 1, CHANNEL_ORDERING_RGBA );

        ConstCPUProcessorRcPtr cpu  = p->getOptimizedCPUProcessor(OPTIMIZATION_NONE);
        cpu->apply(descSrc, descDst);

        fingerprints.sceneRefTestVals = out;
    }
    catch (...) 
    { 
        fingerprints.sceneRefTestVals = ACESvals;
    }

    const int m = config->getNumColorSpaces(SEARCH_REFERENCE_SPACE_DISPLAY, COLORSPACE_ALL);
    if (m == 0)
    {
        return;
    }

    try
    {
        // First check if the config recognizes one of the common names.
        ConstColorSpaceRcPtr cs;
        cs = config->getColorSpace("cie_xyz_d65_interchange");
        if (!cs)
        {
            cs = config->getColorSpace("CIE-XYZ-D65");
            if (!cs)
            {
                cs = config->getColorSpace("CIE XYZ-D65");
                if (!cs)
                {
                    // Otherwise, see if it's present using a different name.
                    ConstConfigRcPtr builtinConfig = Config::CreateFromBuiltinConfig("ocio://cg-config-latest");
                    const char * cs_name = 
                        Config::IdentifyBuiltinColorSpace(config, builtinConfig, "cie_xyz_d65_interchange");
                    cs = config->getColorSpace(cs_name);
                }
            }
        }

        ConstTransformRcPtr toRef = getTransformForDir(cs, COLORSPACE_DIR_TO_REFERENCE);
        p = config->getProcessor(ctx, toRef, TRANSFORM_DIR_FORWARD);

        const size_t n = XYZvals.size();
        std::vector<float> out(n, 0.f);

        PackedImageDesc descSrc( &XYZvals[0], (long) n / 4, 1, CHANNEL_ORDERING_RGBA );
        PackedImageDesc descDst( &out[0], (long) n / 4, 1, CHANNEL_ORDERING_RGBA );

        ConstCPUProcessorRcPtr cpu  = p->getOptimizedCPUProcessor(OPTIMIZATION_NONE);
        cpu->apply(descSrc, descDst);

        fingerprints.displayRefTestVals = out;
    }
    catch (...) 
    { 
        fingerprints.displayRefTestVals = XYZvals;
    }
}
// clang-format on


// clang-format off
// Slightly modified from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026:
//   - Take OCIO Context into account when computing fingerprints.
// Calculate a fingerprint for every color space in a base config. These will be used
// to compare against color spaces in an input config for merging. Store the results in
// the fingerprint struct.
//
void initializeColorSpaceFingerprints(
    ColorSpaceFingerprints & fingerprints,
    std::unordered_map<std::string, Fingerprint> & by_name,
    const ConstConfigRcPtr & config,
    const ConstContextRcPtr & context)
{
    SuspendCacheGuard srcGuard(config);

    const auto simpleSpaces = get_simple_color_spaces(config);
    std::unordered_set<std::string> simpleSpaceSet(simpleSpaces.begin(),
                                                   simpleSpaces.end());

    if (by_name.empty()) {
        fingerprints.vec.clear();
        fingerprints.vec.reserve(simpleSpaceSet.size());
    }

    for (const auto & name : simpleSpaceSet)
    {
        if (by_name.count(name)) {
            continue;
        }
        ConstColorSpaceRcPtr cs = config->getColorSpace(context->resolveStringVar(name.c_str()));
        if (!cs || cs->isData())
        {
            // Don't put data color spaces in the collection.
            continue;
        }
        if (cs->hasCategory("is-unique"))
        {
            // Don't fingerprint color spaces with this category.
            // This provides a way to identify color spaces that must not be replaced.
            // TODO: Perhaps fingerprint everything, and move this to the merge function?
            continue;
        }

        ConstTransformRcPtr tFrom = cs->getTransform(COLORSPACE_DIR_FROM_REFERENCE);
        ConstTransformRcPtr tTo = cs->getTransform(COLORSPACE_DIR_TO_REFERENCE);
        if (tFrom && tTo)
        {
            // Don't bother with color spaces that have both directions defined,
            // these are more complicated and less likely to be duplicates.
            continue;
        }

        std::vector<float> fp;
        const bool skipColorSpace
            = calcColorSpaceFingerprint(fp, fingerprints, config, cs, context);
        if (!skipColorSpace)
        {
            Fingerprint fprint;
            fprint.csName = cs->getName();
            fprint.type = cs->getReferenceSpaceType();
            fprint.vals = fp;
            fingerprints.vec.push_back(fprint);
            by_name.emplace(fprint.csName, fprint);
        }
    }
}
// clang-format on


static OCIO::ConstContextRcPtr
make_context_with_overrides(
    const OCIO::ConstConfigRcPtr& config,
    const std::map<std::string, std::string>& context_vars)
{
    if (!config)
        return nullptr;
    OCIO::ConstContextRcPtr context = config->getCurrentContext();
    if (!context_vars.empty()) {
        OCIO::ContextRcPtr ctx = context->createEditableCopy();
        for (const auto& kv : context_vars) {
            ctx->setStringVar(kv.first.c_str(), kv.second.c_str());
        }
        context = ctx;
    }
    return context;
}

static std::string
fingerprint_cache_key(const ConstConfigRcPtr& config,
                      const ConstContextRcPtr& context)
{
    if (!config)
        return "";
    ConstContextRcPtr ctx = context ? context : config->getCurrentContext();
    const std::string config_id = config->getCacheID();
    const std::string ctx_id    = ctx ? ctx->getCacheID() : std::string();
    // Example key: "ctx:abc123@cfg:deadbeef"
    return Strutil::fmt::format("{}@{}", ctx_id, config_id);
}

FingerprintCacheEntry
get_fingerprint_cache_entry(const ConstConfigRcPtr& config,
                            const ConstContextRcPtr& context,
                            FingerprintCacheMap& cache, std::mutex& cache_mutex)
{
    FingerprintCacheEntry entry;
    if (!config)
        return entry;

    const std::string cacheID = fingerprint_cache_key(config, context);
    entry.cache_id            = cacheID;
    {
        std::lock_guard<std::mutex> lock(cache_mutex);
        auto it = cache.find(cacheID);
        if (it != cache.end())
            return it->second;
    }

    Timer timer;
    entry.cache_id        = cacheID;
    ConstContextRcPtr ctx = context ? context : config->getCurrentContext();
    if (!entry.test_vals_initialized) {
        initializeTestVals(entry.fingerprints, config);
        entry.test_vals_initialized = true;
    }
    initializeColorSpaceFingerprints(entry.fingerprints, entry.by_name, config,
                                     ctx);
    entry.seconds += timer.lap();

    {
        std::lock_guard<std::mutex> lock(cache_mutex);
        cache.emplace(cacheID, entry);
    }

    return entry;
}

bool
get_cached_fingerprint_for_colorspace(const ConstConfigRcPtr& config,
                                      const ConstColorSpaceRcPtr& cs,
                                      const ConstContextRcPtr& context,
                                      ColorSpaceFingerprints& fingerprints,
                                      std::vector<float>& fingerprintVals,
                                      FingerprintCacheMap& cache,
                                      std::mutex& cache_mutex)
{
    if (!config || !cs)
        return false;

    const std::string cacheID = fingerprint_cache_key(config, context);
    {
        std::lock_guard<std::mutex> lock(cache_mutex);
        auto it = cache.find(cacheID);
        if (it != cache.end()) {
            auto found = it->second.by_name.find(cs->getName());
            if (found != it->second.by_name.end()
                && found->second.type == cs->getReferenceSpaceType()) {
                fingerprintVals = found->second.vals;
                return true;
            }
            fingerprints = it->second.fingerprints;
        }
    }

    // Ensure fingerprints are initialized for this config if not already cached.
    FingerprintCacheEntry entry
        = get_fingerprint_cache_entry(config, context, cache, cache_mutex);
    fingerprints = entry.fingerprints;
    auto found   = entry.by_name.find(cs->getName());
    if (found != entry.by_name.end()
        && found->second.type == cs->getReferenceSpaceType()) {
        fingerprintVals = found->second.vals;
        return true;
    }

    return false;
}

std::vector<float>
get_colorspace_fingerprint(const ConstConfigRcPtr& config,
                           string_view colorspace,
                           const ConstContextRcPtr& context,
                           FingerprintCacheMap& cache, std::mutex& cache_mutex)
{
    std::vector<float> inputVals;
    if (!config || colorspace.empty())
        return inputVals;

    ConstColorSpaceRcPtr cs = config->getColorSpace(c_str(colorspace));
    if (!cs || cs->isData())
        return inputVals;

    ConstContextRcPtr ctx = context ? context : config->getCurrentContext();
    ColorSpaceFingerprints fingerprints;
    bool have_cached
        = get_cached_fingerprint_for_colorspace(config, cs, ctx, fingerprints,
                                                inputVals, cache, cache_mutex);
    if (have_cached)
        return inputVals;

    Timer timer;
    const bool skipColorSpace
        = calcColorSpaceFingerprint(inputVals, fingerprints, config, cs, ctx);
    if (skipColorSpace || inputVals.empty())
        return std::vector<float>();

    Fingerprint fprint;
    fprint.csName = cs->getName();
    fprint.type   = cs->getReferenceSpaceType();
    fprint.vals   = inputVals;

    const std::string cacheID = fingerprint_cache_key(config, ctx);
    {
        std::lock_guard<std::mutex> lock(cache_mutex);
        auto it = cache.find(cacheID);
        if (it != cache.end()) {
            if (!it->second.by_name.count(fprint.csName)) {
                it->second.by_name.emplace(fprint.csName, fprint);
                it->second.fingerprints.vec.push_back(fprint);
                it->second.seconds += timer.lap();
            }
        } else {
            FingerprintCacheEntry entry;
            entry.cache_id     = cacheID;
            entry.fingerprints = fingerprints;
            entry.by_name.emplace(fprint.csName, fprint);
            entry.fingerprints.vec.push_back(fprint);
            entry.seconds = timer.lap();
            cache.emplace(cacheID, entry);
        }
    }

    return inputVals;
}

std::string
find_colorspace_from_fingerprint(const ConstConfigRcPtr& config,
                                 cspan<const float> fingerprint,
                                 ReferenceSpaceType refSpaceType,
                                 const ConstContextRcPtr& context,
                                 FingerprintCacheMap& cache,
                                 std::mutex& cache_mutex)
{
    if (!config || fingerprint.empty())
        return "";

    FingerprintCacheEntry entry
        = get_fingerprint_cache_entry(config, context, cache, cache_mutex);
    const float absTolerance = 5e-3f;
    const size_t n           = fingerprint.size();
    for (const auto& fp : entry.fingerprints.vec) {
        if (fp.type != refSpaceType)
            continue;
        if (fp.vals.size() != n)
            continue;

        bool match = true;
        for (size_t i = 0; i < n; ++i) {
            if (std::abs(fp.vals[i] - fingerprint[i]) > absTolerance) {
                match = false;
                break;
            }
        }
        if (match)
            return fp.csName;
    }
    return "";
}

FastColorSpaceMatcher::FastColorSpaceMatcher(const ConstConfigRcPtr& baseConfig,
                                             FingerprintCacheMap& cache,
                                             std::mutex& cache_mutex)
    : m_cache(&cache)
    , m_cache_mutex(&cache_mutex)
{
    FingerprintCacheEntry entry = get_fingerprint_cache_entry(
        baseConfig, baseConfig ? baseConfig->getCurrentContext() : nullptr,
        cache, cache_mutex);
    m_base_fingerprints = entry.fingerprints;
    const char* name    = baseConfig ? baseConfig->getName() : nullptr;
    m_baseConfigName    = (name && *name) ? name
                                          : (baseConfig ? baseConfig->getCacheID()
                                                        : std::string());
}

std::string
FastColorSpaceMatcher::findEquivalentColorspace(
    const ConstConfigRcPtr& inputConfig, string_view csName,
    const ConstContextRcPtr& context) const
{
    if (!inputConfig || csName.empty())
        return "";

    ConstContextRcPtr ctx   = context ? context
                                      : inputConfig->getCurrentContext();
    csName                  = ctx->resolveStringVar(c_str(csName));
    ConstColorSpaceRcPtr cs = inputConfig->getColorSpace(c_str(csName));

    if (!cs || cs->isData())
        return "";

    std::vector<float> inputVals;
    ColorSpaceFingerprints input_fingerprints;
    bool have_cached
        = get_cached_fingerprint_for_colorspace(inputConfig, cs, ctx,
                                                input_fingerprints, inputVals,
                                                *m_cache, *m_cache_mutex);

    if (!have_cached) {
        Timer timer;
        const bool skipColorSpace
            = calcColorSpaceFingerprint(inputVals, input_fingerprints,
                                        inputConfig, cs, ctx);
        if (skipColorSpace || inputVals.empty())
            return "";

        Fingerprint fprint;
        fprint.csName = cs->getName();
        fprint.type   = cs->getReferenceSpaceType();
        fprint.vals   = inputVals;

        const std::string cacheID = fingerprint_cache_key(inputConfig, ctx);
        {
            std::lock_guard<std::mutex> lock(*m_cache_mutex);
            auto it = m_cache->find(cacheID);
            if (it != m_cache->end()) {
                if (!it->second.by_name.count(fprint.csName)) {
                    it->second.by_name.emplace(fprint.csName, fprint);
                    it->second.fingerprints.vec.push_back(fprint);
                    it->second.seconds += timer.lap();
                }
            }
        }
    }

    if (inputVals.empty())
        return "";

    return findEquivalentColorspaceFromFingerprint(inputVals,
                                                   cs->getReferenceSpaceType());
}

std::string
FastColorSpaceMatcher::findEquivalentColorspaceFromFingerprint(
    const std::vector<float>& inputVals, ReferenceSpaceType refSpaceType) const
{
    const float absTolerance = 5e-3f;
    const size_t n           = inputVals.size();
    for (const auto& fp : m_base_fingerprints.vec) {
        if (fp.type != refSpaceType)
            continue;

        bool match = true;
        for (size_t i = 0; i < n; ++i) {
            if (std::abs(fp.vals[i] - inputVals[i]) > absTolerance) {
                match = false;
                break;
            }
        }
        if (match)
            return fp.csName;
    }
    return "";
}

// Copy-pasted from src/OpenColorIO/src/ConfigUtils.h/cpp on 1/22/2026
// If the base config contains a color space equivalent to inputCS, return its name.
// Return an empty string if no equivalent color space is found (within the tolerance).
// The ref_space_type specifies the type of inputCS and determines which part of the
// config is searched.
//
std::string
findEquivalentColorspace(const ColorSpaceFingerprints& fingerprints,
                         const ConstConfigRcPtr& inputConfig,
                         const ConstColorSpaceRcPtr& inputCS)
{
    // The fingerprints must first be initialized from the base config.
    // NB: The inputConfig/inputCS must use the same reference space as the base config.
    // In general, this means that updateReferenceColorspace must be called on inputCS
    // before calling this function.

    // TODO: Should data spaces ever be replaced?
    if (inputCS->isData()) {
        return "";
    }

    // Calculate the fingerprint of inputCS from inputConfig.
    std::vector<float> inputVals;
    const bool skipColorSpace = calcColorSpaceFingerprint(
        inputVals, fingerprints, inputConfig, inputCS,
        inputConfig ? inputConfig->getCurrentContext() : nullptr);
    if (skipColorSpace) {
        return "";
    }

    // TODO: Before looping over all color spaces, check to see if there's one with the same name.
    // TODO: Perhaps add a hash based on the transform cacheIDs and check that before trying
    // to compare processed pixel values?

    // Increased from 1e-3 to 5e-3 to allow for use of either Bradford or CAT02 adaptation.
    const float absTolerance = 5e-3f;

    // Compare to the fingerprints from the base config.
    const size_t n = inputVals.size();
    for (const auto& fp : fingerprints.vec) {
        // Only compare color spaces that are using the same reference space type.
        if (fp.type != inputCS->getReferenceSpaceType()) {
            continue;
        }

        bool matchFound = true;
        for (size_t i = 0; i < n; i++) {
            // Comparison is done in the color space, not the reference space.
            // Could be linear, gamma-corrected, or log encoding.
            // TODO: Could adjust the comparison based on the color space encoding.
            if (!Imath::equalWithAbsError(inputVals[i], fp.vals[i],
                                          absTolerance)) {
                matchFound = false;
                continue;
            }
        }
        if (matchFound) {
            return fp.csName;
        }
    }

    return "";
}

namespace {

    bool fileTransformIsBlockable(const ConstFileTransformRcPtr& fileTransform)
    {
        if (!fileTransform) {
            return true;
        }
        const char* src = fileTransform->getSrc();
        if (!src || !*src) {
            return true;
        }
        if (Strutil::iends_with(src, ".spi1d")
            || Strutil::iends_with(src, ".spimtx")) {
            return false;
        }
        return true;
    }

    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstContextRcPtr& context,
                                    const ConstTransformRcPtr& transform,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit);
    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstContextRcPtr& context,
                                    const char* name,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit);
    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstTransformRcPtr& transform,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit);

    bool colorSpaceHasBlockableTransform(const ConstConfigRcPtr& config,
                                         const ConstColorSpaceRcPtr& cs,
                                         std::unordered_set<std::string>& keep,
                                         std::unordered_set<std::string>& omit)
    {
        if (!cs) {
            return true;
        }
        const char* csName = cs->getName();
        if (cs->isData()) {
            if (csName && *csName)
                omit.insert(csName);
            return true;
        }
        if (csName && keep.count(csName)) {
            return false;
        }

        ConstTransformRcPtr toRef = cs->getTransform(
            COLORSPACE_DIR_TO_REFERENCE);
        if (toRef && containsBlockableTransform(config, toRef, keep, omit)) {
            if (csName && *csName)
                omit.insert(csName);
            return true;
        }

        ConstTransformRcPtr fromRef = cs->getTransform(
            COLORSPACE_DIR_FROM_REFERENCE);
        if (fromRef
            && containsBlockableTransform(config, fromRef, keep, omit)) {
            if (csName && *csName)
                omit.insert(csName);
            return true;
        }

        if (csName && *csName)
            keep.insert(csName);
        return false;
    }

    bool
    namedTransformHasBlockableTransform(const ConstConfigRcPtr& config,
                                        const ConstNamedTransformRcPtr& nt,
                                        std::unordered_set<std::string>& keep,
                                        std::unordered_set<std::string>& omit)
    {
        if (!nt) {
            return true;
        }
        ConstTransformRcPtr fwd = nt->getTransform(TRANSFORM_DIR_FORWARD);
        if (fwd && containsBlockableTransform(config, fwd, keep, omit)) {
            return true;
        }
        ConstTransformRcPtr rev = nt->getTransform(TRANSFORM_DIR_INVERSE);
        if (rev && containsBlockableTransform(config, rev, keep, omit)) {
            return true;
        }
        return false;
    }

    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstContextRcPtr& context,
                                    const char* name,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit)
    {
        if (!name || !*name) {
            return true;
        }
        ConstContextRcPtr ctx = context ? context : config->getCurrentContext();
        auto name_cs          = ctx->resolveStringVar(c_str(name));


        ConstColorSpaceRcPtr cs = config->getColorSpace(c_str(name_cs));
        if (cs) {
            if (omit.count(c_str(cs->getName()))) {
                return true;
            }
            if (keep.count(c_str(cs->getName()))) {
                return false;
            }
            return colorSpaceHasBlockableTransform(config, cs, keep, omit);
        }

        ConstNamedTransformRcPtr nt = config->getNamedTransform(c_str(name_cs));
        if (!nt) {
            return true;
        }
        return namedTransformHasBlockableTransform(config, nt, keep, omit);
    }

    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstTransformRcPtr& transform,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit)
    {
        return containsBlockableTransform(config, config->getCurrentContext(),
                                          transform, keep, omit);
    }

    bool containsBlockableTransform(const ConstConfigRcPtr& config,
                                    const ConstContextRcPtr& context,
                                    const ConstTransformRcPtr& transform,
                                    std::unordered_set<std::string>& keep,
                                    std::unordered_set<std::string>& omit)
    {
        if (!transform) {
            return false;
        }

        ConstContextRcPtr ctx = context ? context : config->getCurrentContext();

        switch (transform->getTransformType()) {
        case TRANSFORM_TYPE_LUT3D: return true;
        case TRANSFORM_TYPE_LOOK: return true;
        case TRANSFORM_TYPE_DISPLAY_VIEW: return true;
        case TRANSFORM_TYPE_FILE: {
            ConstFileTransformRcPtr ft = DynamicPtrCast<const FileTransform>(
                transform);
            return fileTransformIsBlockable(ft);
        }
        case TRANSFORM_TYPE_GROUP: {
            ConstGroupTransformRcPtr gt = DynamicPtrCast<const GroupTransform>(
                transform);
            if (!gt)
                return false;
            for (int i = 0, e = gt->getNumTransforms(); i < e; ++i) {
                if (containsBlockableTransform(config, ctx, gt->getTransform(i),
                                               keep, omit)) {
                    return true;
                }
            }
            return false;
        }
        case TRANSFORM_TYPE_COLORSPACE: {
            ConstColorSpaceTransformRcPtr cst
                = DynamicPtrCast<const ColorSpaceTransform>(transform);
            if (!cst) {
                return true;
            }

            const char* src = cst->getSrc();
            const char* dst = cst->getDst();

            auto src_cs_name            = ctx->resolveStringVar(c_str(src));
            auto dst_cs_name            = ctx->resolveStringVar(c_str(dst));
            ConstColorSpaceRcPtr src_cs = config->getColorSpace(
                c_str(src_cs_name));
            ConstColorSpaceRcPtr dst_cs = config->getColorSpace(
                c_str(dst_cs_name));

            if (!src_cs && dst_cs) {
                bool blocked = containsBlockableTransform(
                    config, ctx, c_str(dst_cs->getName()), keep, omit);
                return blocked;
            }
            if (!dst_cs && src_cs) {
                bool blocked = containsBlockableTransform(
                    config, ctx, c_str(src_cs->getName()), keep, omit);
                return blocked;
            }

            if (src_cs && dst_cs) {
                if (omit.count(src_cs->getName())
                    || omit.count(dst_cs->getName())) {
                    return true;
                }
                if (keep.count(c_str(src_cs->getName()))
                    && keep.count(c_str(dst_cs->getName())))
                    return false;
                bool blocked = containsBlockableTransform(
                    config, ctx, c_str(src_cs->getName()), keep, omit);
                if (blocked)
                    return true;
                blocked = containsBlockableTransform(config, ctx,
                                                     c_str(dst_cs->getName()),
                                                     keep, omit);
                return blocked;
            }
            return true;
        }
        default: break;
        }

        return false;
    }

}  // namespace

std::vector<std::string>
get_simple_color_spaces(const ConstConfigRcPtr& config)
{
    std::vector<std::string> simpleSpaces;
    if (!config) {
        return simpleSpaces;
    }

    std::unordered_set<std::string> keep;
    std::unordered_set<std::string> omit;
    ConstContextRcPtr ctx = config->getCurrentContext();

    const int n = config->getNumColorSpaces(SEARCH_REFERENCE_SPACE_ALL,
                                            COLORSPACE_ALL);
    for (int i = 0; i < n; ++i) {
        const char* name
            = config->getColorSpaceNameByIndex(SEARCH_REFERENCE_SPACE_ALL,
                                               COLORSPACE_ALL, i);
        if (!name || !*name) {
            continue;
        }
        if (keep.count(name) || omit.count(name)) {
            continue;
        }
        if (containsBlockableTransform(config, ctx, name, keep, omit)) {
            omit.insert(name);
        } else {
            keep.insert(name);
        }
    }

    simpleSpaces.reserve(keep.size());
    for (const auto& name : keep) {
        simpleSpaces.emplace_back(name);
    }

    return simpleSpaces;
}

std::map<std::string, std::string>
get_simple_color_space_blockers(const ConstConfigRcPtr& config)
{
    std::map<std::string, std::string> blockers;
    if (!config) {
        return blockers;
    }

    std::unordered_set<std::string> keep;
    std::unordered_set<std::string> omit;
    ConstContextRcPtr ctx = config->getCurrentContext();

    const int n = config->getNumColorSpaces(SEARCH_REFERENCE_SPACE_ALL,
                                            COLORSPACE_ALL);
    for (int i = 0; i < n; ++i) {
        const char* name
            = config->getColorSpaceNameByIndex(SEARCH_REFERENCE_SPACE_ALL,
                                               COLORSPACE_ALL, i);
        if (!name || !*name) {
            continue;
        }

        if (containsBlockableTransform(config, ctx, name, keep, omit)) {
            blockers.emplace(name,
                             "blocked by unsupported or complex transform");
            omit.insert(name);
        } else {
            keep.insert(name);
        }
    }

    return blockers;
}


// Return a copy of `config` adapted to match the reference spaces of `otherConfig`.
OCIO::ConfigRcPtr
adaptConfigReferenceSpaces(const OCIO::ConstConfigRcPtr& config,
                           const OCIO::ConstConfigRcPtr& otherConfig)
{
    using namespace OCIO;
    ConstTransformRcPtr inputToBaseScene;
    ConstTransformRcPtr inputToBaseDisplay;
    ConfigUtils::initializeRefSpaceConverters(inputToBaseScene,
                                              inputToBaseDisplay, otherConfig,
                                              config);

    ConfigRcPtr updatedConfig = config->createEditableCopy();
    const int numColorSpaces
        = updatedConfig->getNumColorSpaces(SEARCH_REFERENCE_SPACE_ALL,
                                           COLORSPACE_ALL);
    for (int i = 0; i < numColorSpaces; ++i) {
        const char* name = updatedConfig->getColorSpaceNameByIndex(
            SEARCH_REFERENCE_SPACE_ALL, COLORSPACE_ALL, i);
        ConstColorSpaceRcPtr cs = updatedConfig->getColorSpace(name);
        if (!cs) {
            continue;
        }

        ColorSpaceRcPtr eCS = cs->createEditableCopy();
        if (eCS->getReferenceSpaceType() == REFERENCE_SPACE_DISPLAY) {
            ConfigUtils::updateReferenceColorspace(eCS, inputToBaseDisplay);
        } else {
            ConfigUtils::updateReferenceColorspace(eCS, inputToBaseScene);
        }
        updatedConfig->addColorSpace(eCS);
    }

    try {
        const int numViewTransforms = updatedConfig->getNumViewTransforms();
        for (int i = 0; i < numViewTransforms; ++i) {
            const char* name = updatedConfig->getViewTransformNameByIndex(i);
            ConstViewTransformRcPtr vt = updatedConfig->getViewTransform(name);
            if (!vt) {
                continue;
            }

            ViewTransformRcPtr eVT = vt->createEditableCopy();
            ConfigUtils::updateReferenceView(eVT, inputToBaseScene,
                                             inputToBaseDisplay);
            updatedConfig->addViewTransform(eVT);
        }
    } catch (Exception&) {
    }

    return updatedConfig;
}

}  // namespace ConfigUtils


void
ColorConfig::Impl::initialize_equality_id_map() const
{
    if (!config_)
        return;

    OCIO::ConstContextRcPtr ctx = config_->getCurrentContext();
    const std::string key       = equality_cache_key(config_, ctx);
    // Cache maps a colorspace name -> equality id for this context+config.
    // Example (conceptual): key="ctx:abc@cfg:deadbeef", "ACEScg" -> "lin_ap1_scene".
    {
        spin_rw_read_lock lock(m_mutex);
        if (m_equality_map_initialized_ctx.count(key))
            return;
    }

    tsl::robin_map<std::string, std::string> equalityIdToCs;
    tsl::robin_map<std::string, std::string> csToEqualityId;
    // equalityIdToCs is used for resolving equality ids (and interop_ids)
    // back to config spaces.
    // Example: key="lin_rec709_scene", value="Rec709".

    if (interopconfig_ && config_) {
        auto& matcher            = get_interop_matcher();
        const auto& simpleSpaces = getSimpleColorSpaces();
        for (const auto& name : simpleSpaces) {
            auto name_cs                  = ctx->resolveStringVar(name.c_str());
            OCIO::ConstColorSpaceRcPtr cs = config_->getColorSpace(name_cs);
            if (!cs || cs->isData())
                continue;
            if (cs->hasCategory("is-unique"))
                continue;

            std::string interop
                = matcher.findEquivalentColorspace(config_, name_cs, ctx);
            if (!interop.empty()) {
                csToEqualityId.emplace(name_cs, interop);
                if (m_equality_reverse_cache_enabled.load())
                    equalityIdToCs.emplace(interop, name_cs);
            }
        }
    }

    spin_rw_write_lock lock(m_mutex);
    m_equality_id_to_cs_by_ctx[key] = std::move(equalityIdToCs);
    m_cs_to_equality_id_by_ctx[key] = std::move(csToEqualityId);
    m_equality_map_initialized_ctx.insert(key);
}

string_view
ColorConfig::Impl::get_cached_equality_id(string_view colorspace) const
{
    initialize_equality_id_map();
    OCIO::ConstContextRcPtr ctx = config_ ? config_->getCurrentContext()
                                          : nullptr;
    const std::string key       = equality_cache_key(config_, ctx);
    spin_rw_read_lock lock(m_mutex);
    auto it_ctx = m_cs_to_equality_id_by_ctx.find(key);
    if (it_ctx == m_cs_to_equality_id_by_ctx.end()) {
        return "";
    }
    std::string colorspace_str(colorspace);
    auto it = it_ctx->second.find(colorspace_str);
    if (it == it_ctx->second.end()) {
        return "";
    }
    return it->second;
}

std::map<std::string, std::string>
ColorConfig::Impl::get_equality_ids() const
{
    initialize_equality_id_map();
    OCIO::ConstContextRcPtr ctx = config_ ? config_->getCurrentContext()
                                          : nullptr;
    const std::string key       = equality_cache_key(config_, ctx);
    spin_rw_read_lock lock(m_mutex);
    auto it_ctx = m_cs_to_equality_id_by_ctx.find(key);
    if (it_ctx == m_cs_to_equality_id_by_ctx.end())
        return {};
    return std::map<std::string, std::string>(it_ctx->second.begin(),
                                              it_ctx->second.end());
}

std::map<std::string, std::string>
ColorConfig::Impl::get_equality_ids(
    bool exhaustive, const std::map<std::string, std::string>& context) const
{
    std::map<std::string, std::string> result;
    if (!config_)
        return result;

    OCIO::ConstContextRcPtr ctx
        = ConfigUtils::make_context_with_overrides(config_, context);
    const std::string key = equality_cache_key(config_, ctx);

    if (!exhaustive) {
        {
            spin_rw_read_lock lock(m_mutex);
            auto it_ctx = m_cs_to_equality_id_by_ctx.find(key);
            if (it_ctx != m_cs_to_equality_id_by_ctx.end())
                return std::map<std::string, std::string>(it_ctx->second.begin(),
                                                          it_ctx->second.end());
        }
    }

    auto& matcher = get_interop_matcher();
    tsl::robin_map<std::string, std::string> interop_to_cs;

    std::vector<std::string> color_spaces_all;
    const std::vector<std::string>* color_spaces = nullptr;
    if (!exhaustive) {
        color_spaces = &getSimpleColorSpaces();
    } else {
        color_spaces_all = m_self->getColorSpaceNamesFiltered(true, true, true,
                                                              true, false);
        color_spaces     = &color_spaces_all;
    }

    for (const auto& name : *color_spaces) {
        OCIO::ConstColorSpaceRcPtr cs = config_->getColorSpace(name.c_str());
        if (!cs || cs->isData())
            continue;
        if (cs->hasCategory("is-unique"))
            continue;

        std::string interop = matcher.findEquivalentColorspace(config_, name,
                                                               ctx);
        if (!interop.empty()) {
            result.emplace(name, interop);
            interop_to_cs.emplace(interop, name);
        }
    }

    if (!exhaustive) {
        spin_rw_write_lock lock(m_mutex);
        m_cs_to_equality_id_by_ctx[key]
            = tsl::robin_map<std::string, std::string>(result.begin(),
                                                       result.end());
        m_equality_id_to_cs_by_ctx[key] = std::move(interop_to_cs);
        m_equality_map_initialized_ctx.insert(key);
    }

    return result;
}

const std::vector<std::string>&
ColorConfig::Impl::getSimpleColorSpaces() const
{
    {
        spin_rw_read_lock lock(m_mutex);
        if (m_simple_color_spaces_cached)
            return m_simple_color_spaces_cache;
    }

    auto simple_spaces = ConfigUtils::get_simple_color_spaces(config_);
    std::sort(simple_spaces.begin(), simple_spaces.end());

    {
        spin_rw_write_lock lock(m_mutex);
        if (!m_simple_color_spaces_cached) {
            m_simple_color_spaces_cache  = std::move(simple_spaces);
            m_simple_color_spaces_cached = true;
        }
        return m_simple_color_spaces_cache;
    }
}

std::map<std::string, std::string>
ColorConfig::Impl::get_interop_ids(
    bool strict, bool exhaustive,
    const std::map<std::string, std::string>& context) const
{
    std::map<std::string, std::string> result;
    if (!config_)
        return result;

    std::vector<std::string> color_spaces_all;
    const std::vector<std::string>* color_spaces = nullptr;
    if (!exhaustive) {
        color_spaces = &getSimpleColorSpaces();
    } else {
        color_spaces_all = m_self->getColorSpaceNamesFiltered(true, true, true,
                                                              true, false);
        color_spaces     = &color_spaces_all;
    }

    for (const auto& name : *color_spaces) {
        std::string interop = m_self->get_color_interop_id(name, strict,
                                                           context);
        if (interop.empty())
            continue;
        if (interop.find('\0') != std::string::npos)
            continue;
        result.emplace(name, std::move(interop));
    }
    return result;
}

std::vector<float>
ColorConfig::Impl::get_colorspace_fingerprint(
    string_view colorspace,
    const std::map<std::string, std::string>& context) const
{
    if (!config_)
        return {};

    OCIO::ConstContextRcPtr ctx
        = ConfigUtils::make_context_with_overrides(config_, context);

    string_view resolved = m_self->resolve(colorspace);
    if (resolved.empty())
        return {};

    return ConfigUtils::get_colorspace_fingerprint(config_, resolved, ctx,
                                                   m_fingerprint_cache,
                                                   m_fingerprint_cache_mutex);
}

std::string
ColorConfig::Impl::find_colorspace_from_fingerprint(
    const std::vector<float>& fingerprint, bool display_referred,
    const std::map<std::string, std::string>& context) const
{
    if (!config_ || fingerprint.empty())
        return "";

    OCIO::ConstContextRcPtr ctx
        = ConfigUtils::make_context_with_overrides(config_, context);

    const OCIO::ReferenceSpaceType refSpaceType
        = display_referred ? OCIO::REFERENCE_SPACE_DISPLAY
                           : OCIO::REFERENCE_SPACE_SCENE;

    return ConfigUtils::find_colorspace_from_fingerprint(
        config_, cspan<const float>(fingerprint), refSpaceType, ctx,
        m_fingerprint_cache, m_fingerprint_cache_mutex);
}

std::vector<std::pair<std::string, std::string>>
ColorConfig::Impl::get_intersection(
    const ColorConfig& other,
    const std::map<std::string, std::string>& base_context,
    const std::map<std::string, std::string>& other_context) const
{
    std::vector<std::pair<std::string, std::string>> result;
    if (!config_)
        return result;

    const auto color_spaces
        = m_self->getColorSpaceNamesFiltered(true, true, true, true, false);
    result.reserve(color_spaces.size());

    for (const auto& name : color_spaces) {
        OCIO::ConstColorSpaceRcPtr cs = config_->getColorSpace(name.c_str());
        if (!cs)
            continue;
        const bool display_referred = cs->getReferenceSpaceType()
                                      == OCIO::REFERENCE_SPACE_DISPLAY;
        const auto fingerprint
            = m_self->get_colorspace_fingerprint(name, base_context);
        if (fingerprint.empty())
            continue;
        const std::string match = other.find_colorspace_from_fingerprint(
            fingerprint, display_referred, other_context);
        if (!match.empty())
            result.emplace_back(name, match);
    }

    return result;
}

std::string
ColorConfig::Impl::get_color_interop_id(
    string_view colorspace, bool strict,
    const std::map<std::string, std::string>& context) const
{
    if (!config_)
        return "";

    if (context.empty()) {
        string_view interop = m_self->get_color_interop_id(colorspace, strict);
        return std::string(interop);
    }

    if (!interopconfig_)
        return "";

    if (colorspace.empty())
        return std::string(colorspace);

    std::string colorspace_str(colorspace);

    OCIO::ConstColorSpaceRcPtr cs = config_->getColorSpace(c_str(colorspace));
    if (!cs) {
        string_view resolved = m_self->resolve(colorspace);
        if (!resolved.empty())
            cs = config_->getColorSpace(c_str(resolved));
    }

#if OCIO_VERSION_HEX >= MAKE_OCIO_VERSION_HEX(2, 5, 0)
    if (cs) {
        string_view interop_id = cs->getInteropID();
        if (!interop_id.empty())
            return std::string(interop_id);
    }
#endif
    if (strict)
        return "";

    // Check to see if this colorspace's name or any of its aliases match
    // a known interop ID in the interop config.
    if (cs) {
        auto interop_cs = interopconfig_->getColorSpace(cs->getName());
        if (interop_cs)
            return interop_cs->getName();
        for (size_t i = 0, e = cs->getNumAliases(); i < e; ++i) {
            string_view alias = cs->getAlias(static_cast<int>(i));
            interop_cs        = interopconfig_->getColorSpace(c_str(alias));
            if (interop_cs)
                return interop_cs->getName();
        }
    }
    auto interop_cs = interopconfig_->getColorSpace(colorspace_str.c_str());
    if (interop_cs)
        return interop_cs->getName();

    const auto interop_ids = get_equality_ids(false, context);
    string_view resolved   = m_self->resolve(colorspace);
    if (!resolved.empty()) {
        std::string resolved_str(resolved);
        auto it = interop_ids.find(resolved_str);
        if (it != interop_ids.end())
            return it->second;
    }
    auto it = interop_ids.find(colorspace_str);
    if (it != interop_ids.end())
        return it->second;

    return "";
}

ConfigUtils::FastColorSpaceMatcher&
ColorConfig::Impl::get_interop_matcher() const
{
    if (!m_interop_matcher) {
        std::lock_guard<std::mutex> lock(m_interop_matcher_mutex);
        if (!m_interop_matcher) {
            m_interop_matcher.reset(new ConfigUtils::FastColorSpaceMatcher(
                interopconfig_, m_fingerprint_cache, m_fingerprint_cache_mutex));
        }
    }
    return *m_interop_matcher;
}


//////////////////////////////////////////////////////////////////////////
//
// Image Processing Implementations


bool
ImageBufAlgo::colorconvert(ImageBuf& dst, const ImageBuf& src, string_view from,
                           string_view to, bool unpremult,
                           string_view context_key, string_view context_value,
                           const ColorConfig* colorconfig, ROI roi,
                           int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::colorconvert");
    if (from.empty() || from == "current") {
        // TODO: more robust way to resolve the color space from the ImageSpec
        from = src.spec().get_string_attribute("oiio:Colorspace",
                                               "scene_linear");
    }
    if (from.empty() || to.empty()) {
        dst.errorfmt("Unknown color space name");
        return false;
    }
    ColorProcessorHandle processor;
    {
        if (!colorconfig)
            colorconfig = &ColorConfig::default_colorconfig();
        processor
            = colorconfig->createColorProcessor(colorconfig->resolve(from),
                                                colorconfig->resolve(to),
                                                context_key, context_value);
        if (!processor) {
            if (colorconfig->has_error())
                dst.errorfmt("{}", colorconfig->geterror());
            else
                dst.errorfmt(
                    "Could not construct the color transform {} -> {} (unknown error)",
                    from, to);
            return false;
        }
    }

    logtime.stop(-1);  // transition to other colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    if (ok) {
        // DBG("done, setting output colorspace to {}\n", to);
        dst.specmod().set_colorspace(to);
    }
    return ok;
}



ImageBuf
ImageBufAlgo::colorconvert(const ImageBuf& src, string_view from,
                           string_view to, bool unpremult,
                           string_view context_key, string_view context_value,
                           const ColorConfig* colorconfig, ROI roi,
                           int nthreads)
{
    ImageBuf result;
    bool ok = colorconvert(result, src, from, to, unpremult, context_key,
                           context_value, colorconfig, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::colorconvert() error");
    return result;
}



bool
ImageBufAlgo::colormatrixtransform(ImageBuf& dst, const ImageBuf& src,
                                   M44fParam M, bool unpremult, ROI roi,
                                   int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::colormatrixtransform");
    ColorProcessorHandle processor
        = ColorConfig::default_colorconfig().createMatrixTransform(M);
    logtime.stop();  // transition to other colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    return ok;
}



ImageBuf
ImageBufAlgo::colormatrixtransform(const ImageBuf& src, M44fParam M,
                                   bool unpremult, ROI roi, int nthreads)
{
    ImageBuf result;
    bool ok = colormatrixtransform(result, src, M, unpremult, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::colormatrixtransform() error");
    return result;
}



template<class Rtype, class Atype>
static bool
colorconvert_impl(ImageBuf& R, const ImageBuf& A,
                  const ColorProcessor* processor, bool unpremult, ROI roi,
                  int nthreads)
{
    using namespace ImageBufAlgo;
    using namespace simd;
    // Only process up to, and including, the first 4 channels.  This
    // does let us process images with fewer than 4 channels, which is
    // the intent.
    int channelsToCopy = std::min(4, roi.nchannels());
    if (channelsToCopy < 4)
        unpremult = false;
    // clang-format off
    parallel_image(
        roi, paropt(nthreads),
        [&, unpremult, channelsToCopy, processor](ROI roi) {
            int width = roi.width();
            // Temporary space to hold one RGBA scanline
            vfloat4* scanline;
            OIIO_ALLOCATE_STACK_OR_HEAP(scanline, vfloat4, width);
            float* alpha;
            OIIO_ALLOCATE_STACK_OR_HEAP(alpha, float, width);
            const float fltmin = std::numeric_limits<float>::min();
            ImageBuf::ConstIterator<Atype> a(A, roi);
            ImageBuf::Iterator<Rtype> r(R, roi);
            for (int k = roi.zbegin; k < roi.zend; ++k) {
                for (int j = roi.ybegin; j < roi.yend; ++j) {
                    // Load the scanline
                    a.rerange(roi.xbegin, roi.xend, j, j + 1, k, k + 1);
                    for (int i = 0; !a.done(); ++a, ++i) {
                        vfloat4 v(0.0f);
                        for (int c = 0; c < channelsToCopy; ++c)
                            v[c] = a[c];
                        if (channelsToCopy == 1)
                            v[2] = v[1] = v[0];
                        scanline[i] = v;
                    }

                    // Optionally unpremult. Be careful of alpha==0 pixels,
                    // preserve their color rather than div-by-zero.
                    if (unpremult) {
                        for (int i = 0; i < width; ++i) {
                            float a  = extract<3>(scanline[i]);
                            alpha[i] = a;
                            a        = a >= fltmin ? a : 1.0f;
                            scanline[i] /= vfloat4(a,a,a,1.0f);
                        }
                    }

                    // Apply the color transformation in place
                    processor->apply((float*)&scanline[0], width, 1, 4,
                                     sizeof(float), 4 * sizeof(float),
                                     width * 4 * sizeof(float));

                    // Optionally re-premult. Be careful of alpha==0 pixels,
                    // preserve their value rather than crushing to black.
                    if (unpremult) {
                        for (int i = 0; i < width; ++i) {
                            float a  = alpha[i];
                            a        = a >= fltmin ? a : 1.0f;
                            scanline[i] *= vfloat4(a,a,a,1.0f);
                        }
                    }

                    // Store the scanline
                    float* dstPtr = (float*)&scanline[0];
                    r.rerange(roi.xbegin, roi.xend, j, j + 1, k, k + 1);
                    for (; !r.done(); ++r, dstPtr += 4)
                        for (int c = 0; c < channelsToCopy; ++c)
                            r[c] = dstPtr[c];
                    if (channelsToCopy < roi.chend && (&R != &A)) {
                        // If there are "leftover" channels, just copy them
                        // unaltered from the source.
                        a.rerange(roi.xbegin, roi.xend, j, j + 1, k, k + 1);
                        r.rerange(roi.xbegin, roi.xend, j, j + 1, k, k + 1);
                        for (; !r.done(); ++r, ++a)
                            for (int c = channelsToCopy; c < roi.chend; ++c)
                                r[c] = 0.5 + 10 * a[c];
                    }
                }
            }
        });
    // clang-format on
    return true;
}



// Specialized version where both buffers are in memory (not cache based),
// float data, and we are dealing with 4 channels.
static bool
colorconvert_impl_float_rgba(ImageBuf& R, const ImageBuf& A,
                             const ColorProcessor* processor, bool unpremult,
                             ROI roi, int nthreads)
{
    using namespace ImageBufAlgo;
    using namespace simd;
    OIIO_ASSERT(R.localpixels() && A.localpixels()
                && R.spec().format == TypeFloat && A.spec().format == TypeFloat
                && R.nchannels() == 4 && A.nchannels() == 4);
    parallel_image(roi, paropt(nthreads), [&](ROI roi) {
        int width = roi.width();
        // Temporary space to hold one RGBA scanline
        vfloat4* scanline;
        OIIO_ALLOCATE_STACK_OR_HEAP(scanline, vfloat4, width);
        float* alpha;
        OIIO_ALLOCATE_STACK_OR_HEAP(alpha, float, width);
        const float fltmin = std::numeric_limits<float>::min();
        for (int k = roi.zbegin; k < roi.zend; ++k) {
            for (int j = roi.ybegin; j < roi.yend; ++j) {
                // Load the scanline
                memcpy((void*)scanline, A.pixeladdr(roi.xbegin, j, k),
                       width * 4 * sizeof(float));
                // Optionally unpremult
                if (unpremult) {
                    for (int i = 0; i < width; ++i) {
                        vfloat4 p(scanline[i]);
                        float a  = extract<3>(p);
                        alpha[i] = a;
                        a        = a >= fltmin ? a : 1.0f;
                        if (a == 1.0f)
                            scanline[i] = p;
                        else
                            scanline[i] = p / vfloat4(a, a, a, 1.0f);
                    }
                }

                // Apply the color transformation in place
                processor->apply((float*)&scanline[0], width, 1, 4,
                                 sizeof(float), 4 * sizeof(float),
                                 width * 4 * sizeof(float));

                // Optionally premult
                if (unpremult) {
                    for (int i = 0; i < width; ++i) {
                        vfloat4 p(scanline[i]);
                        float a = alpha[i];
                        a       = a >= fltmin ? a : 1.0f;
                        p *= vfloat4(a, a, a, 1.0f);
                        scanline[i] = p;
                    }
                }
                memcpy(R.pixeladdr(roi.xbegin, j, k), scanline,
                       width * 4 * sizeof(float));  //NOSONAR
            }
        }
    });
    return true;
}



bool
ImageBufAlgo::colorconvert(ImageBuf& dst, const ImageBuf& src,
                           const ColorProcessor* processor, bool unpremult,
                           ROI roi, int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::colorconvert");
    // If the processor is NULL, return false (error)
    if (!processor) {
        dst.errorfmt(
            "Passed NULL ColorProcessor to colorconvert() [probable application bug]");
        return false;
    }

    // If the processor is a no-op and the conversion is being done
    // in place, no work needs to be done. Early exit.
    if (processor->isNoOp() && (&dst == &src))
        return true;

    if (!IBAprep(roi, &dst, &src))
        return false;

    // If the processor is a no-op (and it's not an in-place conversion),
    // use copy() to simplify the operation.
    if (processor->isNoOp()) {
        logtime.stop();  // transition to copy
        return ImageBufAlgo::copy(dst, src, TypeUnknown, roi, nthreads);
    }

    if (unpremult && src.spec().alpha_channel >= 0
        && src.spec().get_int_attribute("oiio:UnassociatedAlpha") != 0) {
        // If we appear to be operating on an image that already has
        // unassociated alpha, don't do a redundant unpremult step.
        unpremult = false;
    }

    if (dst.localpixels() && src.localpixels() && dst.spec().format == TypeFloat
        && src.spec().format == TypeFloat && dst.nchannels() == 4
        && src.nchannels() == 4) {
        return colorconvert_impl_float_rgba(dst, src, processor, unpremult, roi,
                                            nthreads);
    }

    bool ok = true;
    OIIO_DISPATCH_COMMON_TYPES2(ok, "colorconvert", colorconvert_impl,
                                dst.spec().format, src.spec().format, dst, src,
                                processor, unpremult, roi, nthreads);
    return ok;
}



ImageBuf
ImageBufAlgo::colorconvert(const ImageBuf& src, const ColorProcessor* processor,
                           bool unpremult, ROI roi, int nthreads)
{
    ImageBuf result;
    bool ok = colorconvert(result, src, processor, unpremult, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::colorconvert() error");
    return result;
}



bool
ImageBufAlgo::ociolook(ImageBuf& dst, const ImageBuf& src, string_view looks,
                       string_view from, string_view to, bool unpremult,
                       bool inverse, string_view key, string_view value,
                       const ColorConfig* colorconfig, ROI roi, int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::ociolook");
    if (from.empty() || from == "current") {
        // TODO: more robust way to resolve the color space from the ImageSpec
        auto linearspace = colorconfig->resolve(OCIO::ROLE_SCENE_LINEAR);
        from = src.spec().get_string_attribute("oiio:Colorspace", linearspace);
    }
    if (to.empty() || to == "current") {
        // TODO: more robust way to resolve the color space from the ImageSpec
        auto linearspace = colorconfig->resolve(OCIO::ROLE_SCENE_LINEAR);
        to = src.spec().get_string_attribute("oiio:Colorspace", linearspace);
    }
    if (from.empty() || to.empty()) {
        dst.errorfmt("Unknown color space name");
        return false;
    }
    ColorProcessorHandle processor;
    {
        if (!colorconfig)
            colorconfig = &ColorConfig::default_colorconfig();
        processor = colorconfig->createLookTransform(looks,
                                                     colorconfig->resolve(from),
                                                     colorconfig->resolve(to),
                                                     inverse, key, value);
        if (!processor) {
            if (colorconfig->has_error())
                dst.errorfmt("{}", colorconfig->geterror());
            else
                dst.errorfmt(
                    "Could not construct the color transform (unknown error)");
            return false;
        }
    }

    logtime.stop();  // transition to colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    if (ok)
        dst.specmod().set_colorspace(to);
    return ok;
}



ImageBuf
ImageBufAlgo::ociolook(const ImageBuf& src, string_view looks, string_view from,
                       string_view to, bool unpremult, bool inverse,
                       string_view key, string_view value,
                       const ColorConfig* colorconfig, ROI roi, int nthreads)
{
    ImageBuf result;
    bool ok = ociolook(result, src, looks, from, to, unpremult, inverse, key,
                       value, colorconfig, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::ociolook() error");
    return result;
}



bool
ImageBufAlgo::ociodisplay(ImageBuf& dst, const ImageBuf& src,
                          string_view display, string_view view,
                          string_view from, string_view looks, bool unpremult,
                          bool inverse, string_view key, string_view value,
                          const ColorConfig* colorconfig, ROI roi, int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::ociodisplay");
    ColorProcessorHandle processor;
    {
        //bool input_cs_exists_in_current_config = true;
        if (!colorconfig)
            colorconfig = &ColorConfig::default_colorconfig();
        if (from.empty() || from == "current") {
            // TODO: more robust way to resolve the color space from the ImageSpec
            // auto linearspace = colorconfig->resolve(OCIO::ROLE_SCENE_LINEAR);
            from = src.spec().get_string_attribute("oiio:ColorSpace");
            if (from.empty()) {
                dst.errorfmt("Could not determine the input color space.");
                return false;
            } else {
                // TODO: Make sure `from` is a valid color space in the current config.
                // If not, see if it's a color space in the interop config (or
                // the default config, if a custom config was provided), and try to
                // find an equivalent color space in the current config. If the colorspace
                // can only be found in the interop config, that's fine, we'll handle
                // that in ColorConfig::createDisplayTransform(). If the colorspace
                // can only be found in the default config, that's also okay. If the
                // color space cannot be found at all, log an error to the dst ImageBuf
                // and return false.
            }
        }
        from = colorconfig->resolve(from);
        if (display.empty()) {
            display = colorconfig->getDefaultDisplayName();
        } else {
            // TODO: expose way to get all displays, not just active displays
            auto display_names = colorconfig->getDisplayNames();
            // If the specified display isn't found, use the default display
            if (std::find(display_names.begin(), display_names.end(), display)
                == display_names.end()) {
                // TODO: log warning about using default display.
                display = colorconfig->getDefaultDisplayName();
            }
        }
        // TODO: If `from` resolves to a color space from a config other
        // than the current config, see if we can find a color space in
        // the current config with the same encoding value, and use that
        // color space to get the default view. This is a best effort attempt
        // to get a default view appropriate for the specified input color space
        // (w.r.t the config's view rules).
        //
        // TODO: For now, if `from` doesn't exist in the current config, don't
        // provide the argument at all.

        if (view.empty()) {
            if (colorconfig->color_space_exists(from)) {
                view = colorconfig->getDefaultViewName(display, from);
            } else {
                view = colorconfig->getDefaultViewName(display);
                // TODO: log warning about using default view.
            }
        } else {
            // Make sure the specified view actually exists in the config.
            auto view_names = colorconfig->getViewNames(display);
            // If the specified view isn't found, use the default view
            if (std::find(view_names.begin(), view_names.end(), view)
                == view_names.end()) {
                if (colorconfig->color_space_exists(from))
                    view = colorconfig->getDefaultViewName(display, from);
                else
                    view = colorconfig->getDefaultViewName(display);
                // TODO: log warning about using default view.
            }
        }
        processor
            = colorconfig->createDisplayTransform(display, view,
                                                  from,
                                                  looks, inverse, key, value);
        if (!processor) {
            if (colorconfig->has_error())
                dst.errorfmt("{}", colorconfig->geterror());
            else
                dst.errorfmt(
                    "Could not construct the color transform (unknown error)");
            return false;
        }
    }

    logtime.stop();  // transition to colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    if (ok) {
        if (inverse)
            dst.specmod().set_colorspace(colorconfig->resolve(from));
        else {
            if (display.empty() || display == "default")
                display = colorconfig->getDefaultDisplayName();
            if (view.empty() || view == "default")
                view = colorconfig->getDefaultViewName(display,
                                                       colorconfig->resolve(
                                                           from));
            dst.specmod().set_colorspace(
                colorconfig->getDisplayViewColorSpaceName(display, view));
        }
    }
    return ok;
}



ImageBuf
ImageBufAlgo::ociodisplay(const ImageBuf& src, string_view display,
                          string_view view, string_view from, string_view looks,
                          bool unpremult, bool inverse, string_view key,
                          string_view value, const ColorConfig* colorconfig,
                          ROI roi, int nthreads)
{
    ImageBuf result;
    bool ok = ociodisplay(result, src, display, view, from, looks, unpremult,
                          inverse, key, value, colorconfig, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::ociodisplay() error");
    return result;
}



bool
ImageBufAlgo::ociofiletransform(ImageBuf& dst, const ImageBuf& src,
                                string_view name, bool unpremult, bool inverse,
                                const ColorConfig* colorconfig, ROI roi,
                                int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::ociofiletransform");
    if (name.empty()) {
        dst.errorfmt("Unknown filetransform name");
        return false;
    }
    ColorProcessorHandle processor;
    {
        if (!colorconfig)
            colorconfig = &ColorConfig::default_colorconfig();
        processor = colorconfig->createFileTransform(name, inverse);
        if (!processor) {
            if (colorconfig->has_error())
                dst.errorfmt("{}", colorconfig->geterror());
            else
                dst.errorfmt(
                    "Could not construct the color transform (unknown error)");
            return false;
        }
    }

    logtime.stop();  // transition to colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    if (ok)
        // If we can parse a color space from the file name, and we're not inverting
        // the transform, then we'll use the color space name from the file.
        // Otherwise, we'll leave `oiio:ColorSpace` alone.
        // TODO: Use OCIO to extract InputDescription and OutputDescription CLF
        // metadata attributes, if present.
        if (!colorconfig->filepathOnlyMatchesDefaultRule(name))
            dst.specmod().set_colorspace(
                colorconfig->getColorSpaceFromFilepath(name));
    return ok;
}



ImageBuf
ImageBufAlgo::ociofiletransform(const ImageBuf& src, string_view name,
                                bool unpremult, bool inverse,
                                const ColorConfig* colorconfig, ROI roi,
                                int nthreads)
{
    ImageBuf result;
    bool ok = ociofiletransform(result, src, name, unpremult, inverse,
                                colorconfig, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::ociofiletransform() error");
    return result;
}



bool
ImageBufAlgo::ocionamedtransform(ImageBuf& dst, const ImageBuf& src,
                                 string_view name, bool unpremult, bool inverse,
                                 string_view key, string_view value,
                                 const ColorConfig* colorconfig, ROI roi,
                                 int nthreads)
{
    OIIO::pvt::LoggedTimer logtime("IBA::ocionamedtransform");
    ColorProcessorHandle processor;
    {
        if (!colorconfig)
            colorconfig = &ColorConfig::default_colorconfig();
        processor = colorconfig->createNamedTransform(name, inverse, key,
                                                      value);
        if (!processor) {
            if (colorconfig->has_error())
                dst.errorfmt("{}", colorconfig->geterror());
            else
                dst.errorfmt(
                    "Could not construct the color transform (unknown error)");
            return false;
        }
    }

    logtime.stop();  // transition to colorconvert
    bool ok = colorconvert(dst, src, processor.get(), unpremult, roi, nthreads);
    return ok;
}



ImageBuf
ImageBufAlgo::ocionamedtransform(const ImageBuf& src, string_view name,
                                 bool unpremult, bool inverse, string_view key,
                                 string_view value,
                                 const ColorConfig* colorconfig, ROI roi,
                                 int nthreads)
{
    ImageBuf result;
    bool ok = ocionamedtransform(result, src, name, unpremult, inverse, key,
                                 value, colorconfig, roi, nthreads);
    if (!ok && !result.has_error())
        result.errorfmt("ImageBufAlgo::ocionamedtransform() error");
    return result;
}



bool
ImageBufAlgo::colorconvert(span<float> color, const ColorProcessor* processor,
                           bool unpremult)
{
    // If the processor is NULL, return false (error)
    if (!processor) {
        return false;
    }

    // If the processor is a no-op, no work needs to be done. Early exit.
    if (processor->isNoOp())
        return true;

    // Load the pixel
    float rgba[4]      = { 0.0f, 0.0f, 0.0f, 0.0f };
    int channelsToCopy = std::min(4, (int)color.size());
    memcpy(rgba, color.data(), channelsToCopy * sizeof(float));

    const float fltmin = std::numeric_limits<float>::min();

    // Optionally unpremult
    if ((channelsToCopy >= 4) && unpremult) {
        float alpha = rgba[3];
        if (alpha > fltmin) {
            rgba[0] /= alpha;
            rgba[1] /= alpha;
            rgba[2] /= alpha;
        }
    }

    // Apply the color transformation
    processor->apply(rgba, 1, 1, 4, sizeof(float), 4 * sizeof(float),
                     4 * sizeof(float));

    // Optionally premult
    if ((channelsToCopy >= 4) && unpremult) {
        float alpha = rgba[3];
        if (alpha > fltmin) {
            rgba[0] *= alpha;
            rgba[1] *= alpha;
            rgba[2] *= alpha;
        }
    }

    // Store the scanline
    memcpy(color.data(), rgba, channelsToCopy * sizeof(float));

    return true;
}



void
ColorConfig::set_colorspace(ImageSpec& spec, string_view colorspace) const
{
    // If we're not changing color space, don't mess with anything
    string_view oldspace = spec.get_string_attribute("oiio:ColorSpace");
    if (oldspace.size() && colorspace.size() && oldspace == colorspace)
        return;

    // Set or clear the main "oiio:ColorSpace" attribute
    if (colorspace.empty()) {
        spec.erase_attribute("oiio:ColorSpace");
    } else {
        spec.attribute("oiio:ColorSpace", colorspace);
    }

    // Clear a bunch of other metadata that might contradict the colorspace,
    // including some format-specific things that we don't want to propagate
    // from input to output if we know that color space transformations have
    // occurred.
    if (!equivalent(colorspace, "srgb_rec709_scene"))
        spec.erase_attribute("Exif:ColorSpace");
    spec.erase_attribute("tiff:ColorSpace");
    spec.erase_attribute("tiff:PhotometricInterpretation");
    spec.erase_attribute("oiio:Gamma");
}



void
ColorConfig::set_colorspace_rec709_gamma(ImageSpec& spec, float gamma) const
{
    gamma = std::round(gamma * 100.0f) / 100.0f;
    if (fabsf(gamma - 1.0f) <= 0.01f) {
        set_colorspace(spec, "lin_rec709_scene");
    } else if (fabsf(gamma - 1.8f) <= 0.01f) {
        set_colorspace(spec, "g18_rec709_scene");
        spec.attribute("oiio:Gamma", 1.8f);
    } else if (fabsf(gamma - 2.2f) <= 0.01f) {
        set_colorspace(spec, "g22_rec709_scene");
        spec.attribute("oiio:Gamma", 2.2f);
    } else if (fabsf(gamma - 2.4f) <= 0.01f) {
        set_colorspace(spec, "g24_rec709_scene");
        spec.attribute("oiio:Gamma", 2.4f);
    } else {
        set_colorspace(spec, Strutil::fmt::format("g{}_rec709_scene",
                                                  std::lround(gamma * 10.0f)));
        spec.attribute("oiio:Gamma", gamma);
    }
}


void
set_colorspace(ImageSpec& spec, string_view colorspace)
{
    ColorConfig::default_colorconfig().set_colorspace(spec, colorspace);
}

void
set_colorspace_rec709_gamma(ImageSpec& spec, float gamma)
{
    ColorConfig::default_colorconfig().set_colorspace_rec709_gamma(spec, gamma);
}


OIIO_NAMESPACE_END
